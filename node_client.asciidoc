[[set_up_a_lightning_node]]
== Софт для нод Lightning

Як ми побачили в попередніх розділах, нода Lightning - це комп’ютерна система, яка бере участь у мережі Lightning. Мережа Lightning - це не продукт чи компанія, це набір відкритих стандартів, які визначають основную лінію взаємодії. Тому програмне забезпечення для Lightning-нод розробляється різними компаніями та спільнотами. Переважна більшість софту для Lightning - з _відкритим кодом_, тобто має відкритий вихідний код і таку ліцензію, що дозволяє співпрацю, спільний доступ та участь спільноти в процесі розробки. Так само і реалізації нод Lightning, які ми представимо в цьому розділі, мають відкритий код і розроблені спільними зусиллями.

На відміну від Біткоїна, де стандарт визначається _еталонною реалізацією_ в програмному забезпеченні (Bitcoin Core), у Lightning стандарт визначається низкою документів, що називаються _Basis of Lightning Technology (BOLT)_ і знаходяться у репозиторії _lightning-rfc_ за адресою:

https://github.com/lightningnetwork/lightning-rfc

Не існує еталонної реалізації Lightning Network, але є декілька конкуруючих, сумісних з BOLT та інтероперабільних реалізацій, розроблених різними командами та організаціями. Команди, які розробляють програмне забезпечення для Lightning Network, також роблять свій внесок у розробку та еволюцію стандартів BOLT.

Інша велика відмінність між програмним забезпеченням нод Lightning та  нод Біткоїн полягає в тому, що ноди Lightning не мають йти в ногу з правилами консенсусу і можуть мати розширену функціональність за рамками BOLT. Тому різні команди можуть застосовувати різні експериментальні фічі, які пізніше в разі успіху та широкого використання можуть стати частиною BOLT.

У цьому розділі ви дізнаєтесь, як налаштувати кожний з програмних пакетів для найпопулярніших реалізацій ноди Lightning. Ми подали їх в алфавітному порядку, щоб підкреслити, що ми не надаємо переваги жодному із них. Кожен із них має свої сильні та слабкі сторони, і вибір програмного пакету буде залежати від різних факторів. Оскільки вони написані на різних мовах програмування (наприклад Go, C і т.д.), ваш вибір також може залежати від рівня обізнаності в певній мові та в інструментах розробки.

=== Середовище Розробки Lightning

((("development environment", "setup")))Якщо ви розробник, то скоріш за все захочете створити середовище розробки з усіма інструментами, бібліотеками та іншим софтом для написання та запуску софту Lightning. У цій дуже технічній главі ми пройдемося по цьому процесу крок за кроком. Якщо матеріал здається вам занадто глибоким або ви не бажаєте налаштовувати середовище розробки, сміливо переходьте до наступної менш технічної глави.

==== Використання командного рядку

У прикладах цього розділу та в цілому у книзі використовується командний рядок. Це означає, що ви вводите команди в термінал і отримуєте текстові відповіді. Крім того, приклади продемонстровано на операційній системі Linux, останньому стабільному дистрибутиві Ubuntu (Ubuntu 20.04 LTS). Більшість прикладів можна відтворити в інших операційних системах, таких як Windows або Mac OS, з невеликою різницею в командах. Найбільша різниця між операційними системами - це _пакетний менеджер_, який встановлює різні бібліотеки програмного забезпечення та їх залежності. У наших прикладах ми будемо використовувати +apt+, менеджер пакетів для Ubuntu. У Mac OS загальним менеджером пакетів, що використовується для розробки з відкритим кодом, є Homebrew (команда +brew+), який можна знайти за адресою https://brew.sh.

У більшості прикладів ми будемо збирати програмне забезпечення прямо з вихідного коду. Хоча це може бути досить складним завданням, але це дає нам найбільше влади та контролю. Ви можете замість цього використовувати docker-контейнери, пре-компільовані пакети та інші механізми інсталяції, якщо застрягнете!

[TIP]
====
((("$ symbol")))((("shell commands")))((("terminal applications")))У багатьох прикладах цього розділу ми будемо використовувати інтерфейс командного рядка операційної системи (також відомий як "шелл"), доступ до якого здійснюється через програму-термінал. Спочатку шелл відобразить запрошення вводу як індикатор готовності до вашої команди. Потім ви вводите команду і натискаєте "Enter", на яку шелл відповідає деяким текстом і новим запитом вашої наступної команди. Запит може виглядати по-різному у вашій системі, але далі в прикладах він позначатиметься символом +$+. У прикладах, коли ви бачите текст після символу +$+, не вводьте символ +$+, а лише команду, яка слідує за ним. Потім натисніть клавішу Enter, щоб виконати команду. У наведених прикладах рядки, розташовані під кожною командою - це відповіді операційної системи на цю команду. Коли ви побачите наступний префікс +$+, ви зрозумієте, що це нова команда, і вам слід повторити процес.
====

Для сумісності в усіх прикладах з командним рядком ми використовуємо шелл +bash+. Хоча інші шелли працюватимуть в аналогічний спосіб, деякі скрипти написані спеціально для +bash+ і при запуску в іншому шеллі вимагатимуть деяких модифікацій. Для сумісності ви можете інсталювати +bash+ шелл на Windows або Mac OS, а на більшості Linux систем він встановлений за замовчуванням.

==== Скачування репозиторію книги

Всі приклади доступні в онлайн репозиторії книги. Оскільки онлайн репозиторій буде постійно утримуватися в актуальному стані наскільки це можливо, ви завжди зможете знайти там останню версію замість копіювання прикладів із книги.

Щоб скачати репозиторій у вигляді ZIP архіву, відкрийте +github.com/lnbook/lnbook+ і оберіть справа зелену кнопку з написом "Clone or Download".

Також ви можете скористатися командоюю +git+, щоб склонувати репозиторій на свій комп'ютер. Git - це розподілена система контроля версій, що використовується більшістю розробників для спільної розробки програмного забезпечення або відслідковування змін до репозиторіїв. Скачайте та інсталюйте +git+ за інструкцією на https://git-scm.com/

Щоб скопіювати репозиторій на свій комп'ютер, виконайте команду git наступним чином:

[git-clone-lnbook]
----
$ git clone git@github.com:lnbook/lnbook.git
----

Тепер у вас є повна копія репозиторію книги у папці +lnbook+. Всі наступні команди передбачають, що ви запускаєте команди з цієї папки.

=== Контейнери Docker

Більшість розробників використовуєть _контейнери_ - це різновид віртуальної машини, що містить попередьно налаштовану операційну систему та встановлені програми зі всіма необхідними залежностями. Більшість софту Lightning також може бути інстальовано з використанням системи контейнерів на зразок _Docker_ (команда +docker+), яку можна знайти на сайті https://docker.com. Встановлення контейнерів значно простіше, особливо для тих, кто не звик до командного рядка.

Репозиторій книги містить колекцію контейнерів docker, які можна використати для встановлення сумісного середовища розробки, щоб практикуватись і повторювати приклади на будь-якій системі. Завдяки тому, що контейнер - ці ціла операційна система, що має сумісну конфігурацію, ви можете бути впевнені, що приклади працюватимуть на вашому комп'ютері і не хвилюватись щодо залежностей, версій бібліотек або різниці в налаштуваннях.

Контейнери docker найчастіше налаштовані так, щоб бути невеликими, тобто займати мінімум дискового простору. Проте в цій книзі ми використовуємо контейнери для того, щоб _стандартизувати_ середовище і зробити його сумісним для всіх читачів. Крім того, ці контейнери не мають використовуватися для запуску сервісів у бекграунді. Замість цього вони мають використовуватися для тестування прикладів і вивчення взаємодії з софтом. Через це контейнери мають досить великий розмір і містять багато інструментів розробки та утиліт. Зазвичай для зменшення розміру у Linux-контейнерах використовується дистрибутив Alpine. Однак ми використовуємо контейнери на Ubuntu через те, що більшість розробників добре знайомі з Ubuntu, і це для нас важливіше за розмір. 

Ви можете знайти останні конфігурації контейнерів в репозиторії книги у папці +code/docker+. Кожен контейнер знаходиться в окремій папці як видно нижче:

//// $ tree -F --charset=asciii  code
[docker-dir-list]
----
code
`-- docker/
    |-- bitcoind/
    |   |-- bashrc
    |   |-- bitcoind/
    |   |   |-- bitcoin.conf
    |   |   `-- keys/
    |   |       |-- demo_address.txt
    |   |       |-- demo_mnemonic.txt
    |   |       `-- demo_privkey.txt
    |   |-- bitcoind-entrypoint.sh
    |   |-- Dockerfile
    |   `-- mine.sh*
    |-- c-lightning/
    |   |-- bashrc
    |   |-- c-lightning-entrypoint.sh
    |   |-- Dockerfile
    |   |-- fund-c-lightning.sh
    |   |-- lightningd/
    |   |   `-- config
    |   |-- logtail.sh
    |   `-- wait-for-bitcoind.sh
    |-- eclair/
    |   |-- bashrc
    |   |-- Dockerfile
    |   |-- eclair/
    |   |   `-- eclair.conf
    |   |-- eclair-entrypoint.sh
    |   |-- logtail.sh
    |   `-- wait-for-bitcoind.sh
    |-- lnbook-app/
    |   |-- docker-compose.yml
    |   `-- setup-channels.sh
    `-- lnd/
        |-- bashrc
        |-- Dockerfile
        |-- fund-lnd.sh
        |-- lnd/
        |   `-- lnd.conf
        |-- lnd-entrypoint.sh
        |-- logtail.sh
        `-- wait-for-bitcoind.sh
----

==== Інсталяція Docker

Перед початком вам слід встановити систему контейнерів docker на свій комп’ютер. Docker - це відкрита система, яка безкоштовно розповсюджується як _Community Edition_ для багатьох операційних систем, включаючи Windows, Mac OS та Linux. Версії для Windows та Mac називаються _Docker Desktop_ і складаються з віконної програми та інструментів командного рядка. Версія для Linux називається _Docker Engine_ і складається з демона-сервера та інструментів командного рядка. Ми будемо використовувати ідентичні на всіх платформах інструменти командного рядка.

Встановіть Docker для вашої операційної системи, дотримуючись інструкцій _"Get Docker"_ з веб-сайту Docker за адресою:

https://docs.docker.com/get-docker/

Оберіть зі списку свою операційну систему та дотримуйтесь інструкцій із встановлення.

[TIP]
====
Якщо ви інсталюєте на Linux, дотримуйтесь інструкцій пост-інсталяції, щоб переконатися, що ви можете запускати Docker як звичайний користувач замість користувача _root_. Інакше вам потрібно буде додати до всіх команд +docker+ префікс +sudo+ для їх виконання з правами root: +sudo docker+.
====

Після встановлення Docker ви можете протестувати установку, запустивши демонстраційний контейнер +hello-world+ наступним чином:

[docker-hello-world]
----
$ docker run hello-world

Hello from Docker!
This message shows that your installation appears to be working correctly.

[...]
----

==== Базові команди docker

У цьому розділі ми досить широко використовуємо +docker+. Ми будемо використовувати наступні команди та аргументи +docker+:

*Збірка контейнера*

----
docker build [-t tag] [directory]
----

...де +tag+ - це ідентифікатор контейнера, який ми збираємо, а +directory+ - це папка, де знаходяться "контекст" контейнера (папки та файли) та файл визначення (+Dockerfile+).

*Запуск контейнера*

----
docker run -it [--network netname] [--name cname] tag
----

...де +netname+ - це назва мережі docker, +cname+ - це назва, яку ми даємо цьому екземпляру контейнера, а +tag+ - це тег імені, яке ми дали контейнеру при його зборці.

*Запуск команди в контейнері*

----
docker exec cname command
----

...де +cname+ - це ім’я, яке ми дали контейнеру в команді +run+, а +command+ - це програма або скрипт, який ми хочемо запустити всередині контейнера.

*Зупинення контейнера*

У більшості випадків, коли ми запускаємо контейнер у режимі _interactive_ та _terminal_, тобто з флагами +i+ та +t+ (що об'єднані у вигляді +-it+), контейнер можна зупинити, просто натиснувши +CTRL-C+ або вийшовши з оболонки за допомогою команди +exit+ або натиснувши +CTRL-D+. Якщо контейнер не припиняє роботу, ви можете зупинити його з іншого терміналу наступним чином:

----
docker stop cname
----

...де +cname+ це ім'я, яке ми дали контейнеру при запуску.

*Видалення контейнеру по імені*

Якщо ви даєте контейнеру ім'я замість того, щоб docker назвав його випадковим чином, ви не зможете повторно використовувати це ім'я, поки контейнер не буде видалено. У цьому випадку Docker поверне наступну помилку:
----
docker: Error response from daemon: Conflict. The container name "/bitcoind" is already in use...
----

Щоб виправити це, видаліть існуючий екземпляр контейнера:

----
docker rm cname
----

...де +cname+ - ім'я, присвоєне контейнеру (в прикладі з помилкою: +bitcoind+)

*Перелік запущених контейнерів*

----
docker ps
----

Цих основних команд docker вистачить для початку, вони дозволять вам запустити всі приклади з цього розділу. Давайте розглянемо їх у дії в наступних розділах.

=== Bitcoin Core і Regtest

Для роботи більшості реалізацій Lightning-нод потрібен доступ до повної ноди Біткоїн.

Встановлення повної Біткоїн-ноди та синхронізація блокчейну Біткоїну виходить за рамки цієї книги і само по собі є відносно складною справою. Якщо ви хочете спробувати, зверніться до _Mastering Bitcoin_ (https://github.com/bitcoinbook/bitcoinbook), "Chapter 3: Bitcoin Core: The Reference Implementation", де обговорюється встановлення та робота ноди Біткоїн.

Нода Біткоїн здатна працювати в режимі _regtest_, при якому нода локально створює тестову симуляцію блокчейна Біткоїна. У наступних прикладах ми будемо використовувати режим +regtest+, що дозволить нам продемонструвати Lightning без необхідності мати синхронізовану Біткоїн-ноду і без потреби ризикувати будь-якими коштами.

Контейнером для Bitcoin Core є +bitcoind+. Він налаштований на запуск Bitcoin Core в режимі +regtest+ та майнинг нового блоку кожні 10 секунд. RPC знаходиться на порту 18443, ім'я користувача +regtest+, пароль +regtest+. Також ви можете отримати доступ до RPC за допомогою інтерактивного шеллу та запускати команди +bitcoin-cli+ локально.

===== Збірка контейнера Bitcoin Core

Почнемо з збірки та запуску контейнера +bitcoind+. Спочатку виконаємо команду +docker build+:

----
$ cd code/docker
$ docker build -t lnbook/bitcoind bitcoind
Sending build context to Docker daemon  12.29kB
Step 1/25 : FROM ubuntu:20.04 AS bitcoind-base
 ---> c3c304cb4f22
Step 2/25 : RUN apt update && apt install -yqq 	curl gosu jq bash-completion

[...]

Step 25/25 : CMD ["/usr/local/bin/mine.sh"]
 ---> Using cache
 ---> 758051998e72
Successfully built 758051998e72
Successfully tagged lnbook/bitcoind:latest
----

===== Запуск контейнера Bitcoin Core

Далі запустимо контейнер +bitcoind+ і дозволимо йому змайнити кілька блоків. Ми використовуємо команду +docker run+ із флагами _interactive (i)_ та _terminal (t)_, а також аргументом +name+, щоб надати запущеному контейнеру власне ім'я:

----
$ docker run -it --name bitcoind lnbook/bitcoind
Starting bitcoind...
Bitcoin Core starting
bitcoind started
================================================
Importing demo private key
Bitcoin address:  2NBKgwSWY5qEmfN2Br4WtMDGuamjpuUc5q1
Private key:  cSaejkcWwU25jMweWEewRSsrVQq2FGTij1xjXv4x1XvxVRF1ZCr3
================================================

Mining 101 blocks to unlock some bitcoin
[
  "579311009cc4dcf9d4cc0bf720bf210bfb0b4950cdbda0670ff56f8856529b39",
 ...
  "33e0a6e811d6c49219ee848604cedceb0ab161485e1195b1f3576049e4d5deb7"
]
Mining 1 block every 10 seconds
[
  "5974aa6da1636013daeaf730b5772ae575104644b8d6fa034203d2bf9dc7a98b"
]
Balance: 100.00000000
----

Як бачимо, bitcoind запускається і майнить 101 блок. Це пов’язано із тим, що згідно правил консенсусу Біткоїна, щойно видобуті біткоїни не можуть бути витрачені, поки не пройде 100 блоків. Змайнивши 101-ший блок, стає можливим витратити біткоїни, створені у блоці 1. Після цього початкового майнингу новий блок буде майнитись кожні 10 секунд.

На даний момент транзакцій немає (прим.перекл.: окрім coinbase-транзакцій). Але у нас в гаманці є кілька змайнених тестових біткоїнів, які ми можемо витратити. Коли ми підключимо декілька Lightning-нод, ми відправимо до їх гаманців трохи біткоїнів, щоб потім відкрити декілька платіжних каналів між цими Lightning-нодами.

===== Взаємодія з контейнером Bitcoin Core

Ми також можемо взаємодіяти з контейнером +bitcoind+, надсилаючи йому команди шеллу. Контейнер надсилає лог-файл в термінал, відображаючи процес майнингу, що відбувається у bitcoind. Для взаємодії з шеллом ми можемо писати команди в іншому терміналі, використовуючи команду +docker exec+. Оскільки раніше ми дали назву запущеному контейнеру за допомогою аргумента +name+, то ми можемо посилатися на нього за цим ім'ям, коли запускаємо команду +docker exec+. Запустимо спочатку інтерактивний шелл +bash+:

----
$ docker exec -it bitcoind /bin/bash
root@e027fd56e31a:/bitcoind# ps x
  PID TTY      STAT   TIME COMMAND
    1 pts/0    Ss+    0:00 /bin/bash /usr/local/bin/mine.sh
    7 ?        Ssl    0:03 bitcoind -datadir=/bitcoind -daemon
   97 pts/1    Ss     0:00 /bin/bash
  124 pts/0    S+     0:00 sleep 10
  125 pts/1    R+     0:00 ps x
root@e027fd56e31a:/bitcoind#
----

Запуск інтерактивного шеллу пускає нас "всередину" контейнера. Ми логінимось від імени користувача +root+, як видно з префікса +root@+ у підказці нового шеллу: +root@e027fd56e31a:/bitcoind#+. Якщо ми дамо команду +ps x+, то побачимо запущені у бекграунді процеси +bitcoind+ і +mine.sh+. Для виходу із цього шеллу, натисніть +CTRL-D+ або введіть +exit+, і ви повернетесь до шеллу вашої операційної системи.

Замість запуску інтерактивного шеллу ми також можемо дати команду, яка буде виконана всередині контейнера. У наступному прикладі ми запускаємо команду +bitcoin-cli+, щоб отримати інформацію про поточний стан блокчейну:

----
$ docker exec bitcoind bitcoin-cli -datadir=/bitcoind getblockchaininfo
{
  "chain": "regtest",
  "blocks": 149,
  "headers": 149,
  "bestblockhash": "35e97bf507607be010be1daa10152e99535f7b0f9882d0e588c0037d8d9b0ba1",
  "difficulty": 4.656542373906925e-10,
 [...]
  "warnings": ""
}
$
----

Як бачите, нам потрібно вказати для +bitcoin-cli+ шлях до каталогу даних bitcoind за допомогою аргументу +datadir+. Потім ми можемо давати ноді Bitcoin Core RPC-команди і отримувати результати їх роботи у форматі JSON.

Всі наші docker-контейнери мають попередньо встановлений консольний кодер/декодер JSON під назвою +jq+. +jq+ допомагає нам обробляти дані у форматі JSON у консолі або із скриптів. Ви можете надіслати JSON-вивід будь-якої команди до +jq+, використовуючи символ +|+. Цей символ, а також цю операцію називають пайп ("pipe", що означає "труба"). Давайте застосуємо +пайп+ та +jq+ до попередньої команди наступним чином:

----
$ docker exec bitcoind bash -c "bitcoin-cli -datadir=/bitcoind getblockchaininfo | jq .blocks"
189
----

Команда +jq .blocks+ вказує JSON-декодеру +jq+ витягнути поле +blocks+ з результату команди +getblockchaininfo+. В нашому випадку вона витягує та друкує значення 189, яке ми можемо використати в наступній команді.

Як ви побачите в наступних розділах, ми можемо запускати кілька контейнерів одночасно, а потім взаємодіяти з ними окремо. Ми можемо подавати команди для отримання такої інформації, як відкритий ключ ноди Lightning, або для виконання таких дій, як відкриття каналу до іншої ноди. Команди +docker run+ та +docker exec+ разом із +jq+ для декодування JSON - це все, що нам треба для побудови робочої мережі Lightning, що поєднує різні імплементації нод. Це дозволяє нам провести різноманітні експерименти на власному комп’ютері.

=== Lightning-нода c-lightning

C-lightning - це легка, просто настроювана і сумісна зі стандартом реалізація протоколу Lightning Network, розроблена компанією Blockstream в рамках проекту Elements. Цей проект відкритий і спільно розробляється на Github:

https://github.com/ElementsProject/lightning

В наступних розділах ми зробимо docker-контейнер з нодою c-lightning, яка підключається до створеного раніше контейнера bitcoind. Ми також покажемо, як налаштувати та зібрати c-lightning безпосередньо з вихідного коду.

==== c-lightning у вигляді docker-контейнера

Поставка програмного забезпечення c-lightning має свій docker-контейнер, але він призначений для запуску c-lightning "на продакшені". Для демонстраційних цілей ми використаємо дещо простіший контейнер c-lightning.

Почнемо зі створення контейнера докера c-lightning з файлів книги, які ви раніше завантажили в каталог з іменем +lnbook+. Як і раніше, ми будемо використовувати команду +docker build+ у підкаталозі +code/docker+. Позначимо контейнер тегом +lnbook/c-lightning+ наступним чином:
----
$ cd code/docker
$ docker build -t lnbook/c-lightning c-lightning
Sending build context to Docker daemon  10.24kB
Step 1/21 : FROM lnbook/bitcoind AS c-lightning-base
 ---> 758051998e72
Step 2/21 : RUN apt update && apt install -yqq 	software-properties-common

[...]

Step 21/21 : CMD ["/usr/local/bin/logtail.sh"]
 ---> Using cache
 ---> e63f5aaa2b16
Successfully built e63f5aaa2b16
Successfully tagged lnbook/c-lightning:latest
----

Тепер наш контейнер створено і він готовий до роботи. Перед запуском контейнера c-lightning, нам треба запустити контейнер bitcoind в іншому терміналі, оскільки c-lightning залежить від bitcoind. Нам також потрібно буде створити мережу docker, яка дозволяє контейнерам з'єднатись між собою так, ніби вони розташовані в одній локальній мережі.

[TIP]
====
Контейнери docker можуть "спілкуватися" між собою через віртуальну локальну мережу під управлінням системи docker. Кожен контейнер може мати власне ім'я, а інші контейнери можуть використовувати це ім'я для визначення його IP-адреси та підключення.
====

==== Налаштування мережі docker

Як тільки мережа docker налаштована, docker активуватиме мережу на нашому локальному комп’ютері під час кожного запуску, наприклад після перезавантаження комп'ютера. Тому нам потрібно одноразово налаштувати мережу за допомогою команди +docker network create+. Сама назва мережі не має значення, але вона повинна бути унікальною на нашому комп’ютері. За замовчуванням docker має три мережі з іменами +host+, +bridge+ та +none+. Ми назвемо нашу нову мережу +lnbook+ і створимо її наступним чином:

----
$ docker network create lnbook
ad75c0e4f87e5917823187febedfc0d7978235ae3e88eca63abe7e0b5ee81bfb
$ docker network ls
NETWORK ID          NAME                DRIVER              SCOPE
7f1fb63877ea        bridge              bridge              local
4e575cba0036        host                host                local
ad75c0e4f87e        lnbook              bridge              local
ee8824567c95        none                null                local
----

Як ви можете бачити, команда +docker network ls+ видає нам перелік мереж docker. Нашу мережу +lnbook+ створено. Ми можемо ігнорувати ідентифікатор мережі, так як він використовується автоматично.

==== Запуск контейнерів bitcoind і c-lightning

Наступним кроком є запуск контейнерів bitcoind і c-lightning та підключення їх до мережі +lnbook+. Щоб запустити контейнер у певній мережі, ми повинні додати аргумент +network+ до команди +docker run+. Щоб контейнери могли легко знаходити один одного, ми дамо кожному із них ім'я за допомогою аргументу +name+. Ми запускаємо bitcoind наступним чином:

----
$ docker run -it --network lnbook --name bitcoind lnbook/bitcoind
----

Ви маєте побачити, як запускається bitcoind і починається майнинг блоків кожні 10 секунд. Залиште його запущеним і відкрийте нове вікно терміналу для запуску c-lightning. Ми використовуємо подібну команду +docker run+ з аргументами +network+ та +name+ для запуску c-lightning наступним чином:

----
$ docker run -it --network lnbook --name c-lightning lnbook/c-lightning
Waiting for bitcoind to start...
Waiting for bitcoind to mine blocks...
Starting c-lightning...
[...]
Startup complete
Funding c-lightning wallet
{"result":"e1a392ce2c6af57f8ef1550ccb9a120c14b454da3a073f556b55dc41592621bb","error":null,"id":"c-lightning-container"}
[...]
2020-06-22T14:26:09.802Z DEBUG lightningd: Opened log file /lightningd/lightningd.log

----

Контейнер c-lightning запускається і підключається до контейнера bitcoind через мережу docker. Спочатку наша нода c-lightning чекатиме на запуск bitcoind, а потім чекатиме поки bitcoind змайнить трохи біткоїнів у свій гаманець. Нарешті, в ході запуску контейнера, скрипт надішле bitcoind-ноді RPC-команду створення транзакції, яка переводить на гаманець c-lightning 10 тестових BTC. Наразі наша нода c-lightning не лише працює, але й навіть володіє кількома тестовими біткоїнами, якими можна погратись!

Як було показано на контейнері bitcoind, ми можемо давати команди нашому контейнеру c-lightning в іншому терміналі для отримання інформації, отримання переліку відкритих каналів тощо. Команда, що дозволяє нам давати інструкції ноді c-lightning, називається +lightning-cli+. Щоб отримати інформацію про ноду, виконайте наступну команду +docker exec+ в іншому вікні терміналу:

----
$ docker exec c-lightning lightning-cli getinfo
{
   "id": "025656e4ef0627bc87638927b8ad58a0e07e8d8d6e84a5699a5eb27b736d94989b",
   "alias": "HAPPYWALK",
   "color": "025656",
   "num_peers": 0,
   "num_pending_channels": 0,
   "num_active_channels": 0,
   "num_inactive_channels": 0,
   "address": [],
   "binding": [
      {
         "type": "ipv6",
         "address": "::",
         "port": 9735
      },
      {
         "type": "ipv4",
         "address": "0.0.0.0",
         "port": 9735
      }
   ],
   "version": "0.8.2.1",
   "blockheight": 140,
   "network": "regtest",
   "msatoshi_fees_collected": 0,
   "fees_collected_msat": "0msat",
   "lightning-dir": "/lightningd/regtest"
}

----

Тепер у нас є перша Lightning-нода, який працює у віртуальній мережі та спілкується з тестовим Біткоїн-блокчейном. Далі в цьому розділі ми запустимо більше нод, з'єднаємо їх між собою і проведемо кілька Lightning-платежів.

У наступній секції ми також розглянемо, як завантажити, налаштувати та скомпілювати c-lightning безпосередньо з вихідного коду. Це необов’язковий та просунутий крок, який навчить вас користуватися інструментами збірки та дозволить вам модифікувати вихідний код c-lighting. Завдяки цим знанням ви зможете написати якийсь свій код, виправити деякі помилки або створити плагін для c-lightning. Якщо ви не плануєте занурюватися у вихідний код або програмувати ноду Lightning, ви можете повністю пропустити наступну секцію. Щойно створений docker-контейнер буде цілком достатнім для більшості прикладів у книзі.

==== Інсталяція c-lightning з вихідного коду

Розробники c-lightning надали детальні інструкції щодо збірки c-lightning із вихідного коду. Ми будемо слідувати інструкціям звідси:

https://github.com/ElementsProject/lightning/blob/master/doc/INSTALL.md

====  Інсталяція необхідних бібліотек та пакунків

Першим кроком є встановлення необхідних бібліотек. Використаємо менеджер пакунків +apt+ для цього:

----
$ sudo apt-get update

Get:1 http://security.ubuntu.com/ubuntu bionic-security InRelease [88.7 kB]
Hit:2 http://eu-north-1b.clouds.archive.ubuntu.com/ubuntu bionic InRelease
Get:3 http://eu-north-1b.clouds.archive.ubuntu.com/ubuntu bionic-updates InRelease [88.7 kB]

[...]

Fetched 18.3 MB in 8s (2,180 kB/s)
Reading package lists... Done

$ sudo apt-get install -y \
  autoconf automake build-essential git libtool libgmp-dev \
  libsqlite3-dev python python3 python3-mako net-tools zlib1g-dev \
  libsodium-dev gettext

Reading package lists... Done
Building dependency tree
Reading state information... Done
The following additional packages will be installed:
  autotools-dev binutils binutils-common binutils-x86-64-linux-gnu cpp cpp-7 dpkg-dev fakeroot g++ g++-7 gcc gcc-7 gcc-7-base libalgorithm-diff-perl

 [...]

Setting up libsigsegv2:amd64 (2.12-2) ...
Setting up libltdl-dev:amd64 (2.4.6-14) ...
Setting up python2 (2.7.17-2ubuntu4) ...
Setting up libsodium-dev:amd64 (1.0.18-1) ...

[...]
$
----

Через кілька хвилин і багато тексту на екрані всі необхідні пакети та бібліотеки буде встановлено. Багато з цих бібліотек також використовуються іншими пакетами Lightning та потрібні для розробки програмного забезпечення загалом.

==== Копіювання вихідного коду c-lightning

Далі ми скопіюємо останню версію c-lightning із репозиторію. Для цього ми використаємо команду +git clone+, яка клонує копію вихідного коду на вашу локальну машину, що дозволить синхронізувати майбутні зміни без необхідності повторного завантаження цілого репозиторію:

----
$ git clone https://github.com/ElementsProject/lightning.git
Cloning into 'lightning'...
remote: Enumerating objects: 24, done.
remote: Counting objects: 100% (24/24), done.
remote: Compressing objects: 100% (22/22), done.
remote: Total 53192 (delta 5), reused 5 (delta 2), pack-reused 53168
Receiving objects: 100% (53192/53192), 29.59 MiB | 19.30 MiB/s, done.
Resolving deltas: 100% (39834/39834), done.

$ cd lightning

----

Тепер в нас є копія c-lightning у каталозі +lightning+, і ми виконали команду +cd+ (змінити каталог) для переходу в нього.

==== Компіляція вихідного коду c-lightning

Далі ми використовуємо набір _скриптів для збірки_, які зазвичай доступні у багатьох проектах з відкритим кодом. Ці _скрипти для збірки_ використовують команди +configure+ і +make+, які дозволяють нам:

* Вказати параметри збірки та перевірити необхідні залежності (+configure+).
* Зібрати та інсталювати програми та бібліотеки (+make+).

Запуск +configure+ з опцією +help+ виведе на екран список доступних опцій:

----
$ ./configure --help
Usage: ./configure [--reconfigure] [setting=value] [options]

Options include:
  --prefix= (default /usr/local)
    Prefix for make install
  --enable/disable-developer (default disable)
    Developer mode, good for testing
  --enable/disable-experimental-features (default disable)
    Enable experimental features
  --enable/disable-compat (default enable)
    Compatibility mode, good to disable to see if your software breaks
  --enable/disable-valgrind (default (autodetect))
    Run tests with Valgrind
  --enable/disable-static (default disable)
    Static link sqlite3, gmp and zlib libraries
  --enable/disable-address-sanitizer (default disable)
    Compile with address-sanitizer
----

Для цього прикладу нам не потрібно змінювати жодні опції, встановлені за замовчуванням. Отже, ми знову запускаємо +configure+ без жодних опцій:

----
$ ./configure

Compiling ccan/tools/configurator/configurator...done
checking for python3-mako... found
Making autoconf users comfortable... yes
checking for off_t is 32 bits... no
checking for __alignof__ support... yes

[...]

Setting COMPAT... 1
PYTEST not found
Setting STATIC... 0
Setting ASAN... 0
Setting TEST_NETWORK... regtest
$
----

Далі запустимо збірку бібліотек, компонентів та виконуваних файлів проекту c-lightning за допомогою команди +make+. Ця процедура займе кілька хвилин і сильно навантажить центральний процесор та диск вашого комп’ютера. Чекайте шуму від кулерів! Запустіть +make+:

----
$ make

cc -DBINTOPKGLIBEXECDIR="\"../libexec/c-lightning\"" -Wall -Wundef -Wmis...

[...]

cc   -Og  ccan-asort.o ccan-autodata.o ccan-bitmap.o ccan-bitops.o ccan-...

----

Якщо все буде добре, то ви не побачите жодного повідомлення +ERROR+, яке б зупинило виконання вищевказаної команди. Програмний пакет c-lightning скомпільовано із вихідного коду, і тепер ми можемо інсталювати створені на попередньому кроці програми:

----
$ sudo make install

mkdir -p /usr/local/bin
mkdir -p /usr/local/libexec/c-lightning
mkdir -p /usr/local/libexec/c-lightning/plugins
mkdir -p /usr/local/share/man/man1
mkdir -p /usr/local/share/man/man5
mkdir -p /usr/local/share/man/man7
mkdir -p /usr/local/share/man/man8
mkdir -p /usr/local/share/doc/c-lightning
install cli/lightning-cli lightningd/lightningd /usr/local/bin
[...]
----

Щоб перевірити, що програми +lightningd+ та +lightning-cli+ було встановлено правильно, ми запитаємо їх версії:

----
$ lightningd --version
v0.8.1rc2
$ lightning-cli --version
v0.8.1rc2
----

Можливо, ви побачите відмінну версію від наведеної вище, оскільки програмне забезпечення продовжуватиме розвиватися після публікації цієї книги. Однак незалежно від того, яку версію ви бачите, той факт, що команди виконуються та видають інформацію про версію, означає, що вам вдалося зібрати програмне забезпечення c-lightning.

=== Нода Lightning Network Daemon (LND)

Lightning Network Daemon (LND) є повною реалізацією ноди Lightning Network від компанії Lightning Labs. Проект LND пропонує ряд програм, включаючи +lnd+ (сам демон) та +lncli+ (утиліта командного рядка). LND може підключатись до кількох сервісів включно з btcd (повна нода), bitcoind (Bitcoin Core) та neutrino (новий експериментальний легкий клієнт). LND написаний мовою програмування Go. Проект відкритий і спільно розробляється на Github:

https://github.com/LightningNetwork/lnd

У наступних секціях ми створимо docker-контейнер для запуску LND, зберемо LND з вихідного коду та дізнаємося, як налаштувати та запустити LND.

==== LND у вигляді docker-контейнера

Якщо ви слідкувати за попередніми прикладами з цього розділу, то вже добре знайомі з основними командами docker. У цій секції ми повторимо їх для створення контейнера LND. Контейнер знаходиться в +code/docker/lnd+. В терміналі перейдемо в робочий каталог +code/docker+ і запустимо команду +docker build+:

----
$ cd code/docker
$ docker build -t lnbook/lnd lnd
Sending build context to Docker daemon  9.728kB
Step 1/29 : FROM golang:1.13 as lnd-base
 ---> e9bdcb0f0af9
Step 2/29 : ENV GOPATH /go

[...]

Step 29/29 : CMD ["/usr/local/bin/logtail.sh"]
 ---> Using cache
 ---> 397ce833ce14
Successfully built 397ce833ce14
Successfully tagged lnbook/lnd:latest

----

Тепер наш контейнер створено і він готовий до роботи. Як і у випадку з контейнером c-lightning, який ми створили раніше, контейнер LND також залежить від запущеного екземпляра Bitcoin Core. Як і раніше, нам потрібно запустити контейнер bitcoind в іншому терміналі і підключити до нього LND через мережу docker. Ми вже створили docker мережу під назвою +lnbook+ і використаємо її знову.

[TIP]
====
Зазвичай кожен оператор ноди запускає свою власну ноду Lightning та власну ноду Bitcoin на своєму сервері. В нашому випадку один контейнер bitcoind може обслуговувати багато нод Lightning. В нашій симульованій мережі ми можемо запустити кілька нод Lightning, всі вони підключаються до однієї ноди Bitcoin в режимі regtest.
====

==== Запуск контейнерів bitcoind та LND

Як і раніше, ми запускаємо контейнер bitcoind в одному терміналі, а LND в іншому. Якщо у вас вже запущений контейнер bitcoind, вам не потрібно його перезапускати. Просто залиште його запущеним і пропустіть наступний крок. Для запуску bitcoind в мережі +lnbook+ ми використовуємо +docker run+ наступним чином:

----
$ docker run -it --network lnbook --name bitcoind lnbook/bitcoind
----

Наступним кроком запустимо щойно створений контейнер LND. Як і раніше, нам потрібно під'єднати його до мережі +lnbook+ і дати йому ім'я:

----
$ docker run -it --network lnbook --name lnd lnbook/lnd
Waiting for bitcoind to start...
Waiting for bitcoind to mine blocks...
Starting lnd...
Startup complete
Funding lnd wallet
{"result":"795a8f4fce17bbab35a779e92596ba0a4a1a99aec493fa468a349c73cb055e99","error":null,"id":"lnd-run-container"}

[...]

2020-06-23 13:42:51.841 [INF] LTND: Active chain: Bitcoin (network=regtest)

----

Контейнер LND запускається і підключається до контейнера bitcoind через docker-мережу. Спочатку наша нода LND чекатиме на запуск bitcoind, а потім чекатиме поки bitcoind змайнить трохи біткоїнів у свій гаманець. Нарешті, в ході запуску контейнера, скрипт надішле bitcoind-ноді RPC-команду створення транзакції, яка переводить на гаманець LND 10 тестових BTC.

Як було показано раніше, ми можемо давати команди нашому контейнеру в іншому терміналі для отримання інформації, отримання переліку відкритих каналів тощо. Команда, що дозволяє нам давати інструкції демону +lnd+, називається +lncli+. Щоб отримати інформацію про ноду, виконайте наступну команду +docker exec+ в іншому вікні терміналу:

----
$ docker exec lnd lncli -n regtest getinfo
{
    "version": "0.10.99-beta commit=clock/v1.0.0-85-gacc698a6995b35976950282b29c9685c993a0364",
    "commit_hash": "acc698a6995b35976950282b29c9685c993a0364",
    "identity_pubkey": "03e436739ec70f3c3630a62cfe3f4b6fd60ccf1f0b69a0036f73033c1ac309426e",
    "alias": "03e436739ec70f3c3630",
    "color": "#3399ff",
    "num_pending_channels": 0,
    "num_active_channels": 0,
    "num_inactive_channels": 0,
 [...]
}
----

Тепер у нас є ще одна нода Lightning, яка працює в мережі +lnbook+ і спілкується з bitcoind. Якщо у вас запущений контейнер c-lightning, то зараз працює дві ноди. Вони ще не з'єднані між собою, але невдовзі ми їх з'єднаємо.

За бажанням ви можете запустити будь-яку комбінацію нод LND та c-lightning в тій самій мережі Lightning. Наприклад, щоб запустити другий вузол LND, виконайте команду +docker run+ з іншим ім'ям контейнера, наприклад так:

----
$ docker run -it --network lnbook --name lnd2 lnbook/lnd
----

У наведеній вище команді ми запускаємо інший контейнер LND під назвою +lnd2+. Ви можете вказати будь-яке унікальне ім'я. Якщо ви не вкажете ім'я, docker самостійно створить унікальне ім'я із двох випадкових англійських слів, наприклад "naughty_einstein" ("Вередливий Айнштайн"). Це була справжня назва, яку обрав нам docker, коли ми писали цей параграф. Як смішно!

У наступній секції ми розглянемо, як завантажити та скомпілювати LND безпосередньо з вихідного коду. Це необов’язковий та просунутий крок, який навчить вас користуватися інструментами збірки мови Go та дозволить вам модифікувати вихідний код LND. Завдяки цим знанням ви зможете написати якийсь свій код або виправити деякі помилки. Якщо ви не плануєте занурюватися у вихідний код або програмувати ноду Lightning, ви можете повністю пропустити наступну секцію. Щойно створений docker-контейнер буде цілком достатнім для більшості прикладів у книзі.

==== Інсталяція LND з вихідного коду

У цій секції ми зберемо LND з нуля. LND написаний мовою програмування Go. ЯКЩО ви хочете дізнатись більше про Go, шукайте за запитом +golang+ замість +go+, щоб уникнути нерелевантних результатів. Оскільки LND написаний на Go, а не на C чи C++, він використовує інший спосіб збірки, ніж GNU autotools/make, який ми бачили раніше у c-lightning. Але не засмучуйтесь, це досить легко, ми крок за кроком покажемо як встановити та використовувати інструменти golang. Go - це фантастична мова для спільної розробки програмного забезпечення, оскільки вона дозволяє робити дуже сумісний, чіткий і легкий для читання код незалежно від кількості авторів. Go сфокусований і "мінімалістичний" в плані узгодження різних версій мови. Go - компільована мова, тому вона також є досить ефективною. Давайте зануримось глибше.

Прослідуємо по інструкції з інсталяції, наведеній у проектній документації LND:

https://github.com/lightningnetwork/lnd/blob/master/docs/INSTALL.md

Спочатку встановимо пакет +golang+ та пов'язані з ним бібліотеки. Нам потрібна версія Go 1.13 або пізніша. Офіційні пакети мови Go розповсюджуються у вигляді двійкових файлів з https://golang.org/dl. Для зручності вони також розповсюджуються у вигляді пакетів Debian і доступні за допомогою команди +apt+. Ви можете слідувати інструкціям на https://golang.org/dl або використовувати команди +apt+ для системи Debian/Ubuntu Linux, як описано на https://github.com/golang/go/wiki/Ubuntu:

----
$ sudo apt install golang-go
----

Переконайтесь, що правильна версія встановлена та готова до використання:

----
$ go version
go version go1.13.4 linux/amd64
----

Наша версія 1.13.4, тож ми готові... Далі нам потрібно вказати іншим програмам, де їм шукати код Go. Для цього потрібно встановити змінну середовища +GOPATH+. Зазвичай код Go знаходиться в каталозі з іменем +gocode+ безпосередньо в домашньому каталозі користувача. За допомогою наступних двох команд ми встановлюємо значення змінних середовища +GOPATH+ і +PATH+. Зверніть увагу на те, що домашній каталог користувача називається +~+.

----
$ export GOPATH=~/gocode
$ export PATH=$PATH:$GOPATH/bin
----

Щоб не встановлювати ці змінні середовища кожного разу при відкритті шеллу, ви можете додати ці два рядки до кінця вашого конфігураційного файлу +.bashrc+ у домашньому каталозі за допомогою вибраного вами текстового редактора.

==== Копіювання вихідного коду LND

Як і у випадку з багатьма проектами з відкритим кодом, вихідний код LND знаходиться на Github (www.github.com). Команда +go get+ може отримати її безпосередньо за протоколом git:

----
$ go get -d github.com/lightningnetwork/lnd
----

Як тільки +go get+ закінчить свою роботу, у вас з’явиться підкаталог у +GOPATH+, що містить вихідний код LND.

==== Компіляція вихідного коду LND

Для збірки LND використовується команда +make+. Щоб зібрати проект, ми переходимо в каталог з вихідним кодом LND, а потім запускаємо +make+:

----
$ cd $GOPATH/src/github.com/lightningnetwork/lnd
$ make && make install
----

Після кількох хвилин у вас буде встановлено дві нові команди +lnd+ та +lncli+. Спробуйте їх і перевірте їх версію, щоб переконатися, що вони встановлені:

----
$ lnd --version
lnd version 0.10.99-beta commit=clock/v1.0.0-106-gc1ef5bb908606343d2636c8cd345169e064bdc91
$ lncli --version
lncli version 0.10.99-beta commit=clock/v1.0.0-106-gc1ef5bb908606343d2636c8cd345169e064bdc91
----

Можливо, ви побачите відмінну версію від наведеної вище, оскільки програмне забезпечення продовжуватиме розвиватися після публікації цієї книги. Однак незалежно від того, яку версію ви бачите, той факт, що команди виконуються та видають інформацію про версію, означає, що вам вдалося зібрати програмне забезпечення LND.

=== Lightning нода Eclair

Eclair ("блискавка" французькою мовою) - це реалізація Lightning Network мовою Scala, зроблена компанією ACINQ. Eclair також є одним з найпопулярніших та новаторських мобільних Lightning-гаманців, який ми використовували для демонстрації Lightning-платежу в другому розділі. У цьому розділі ми розглядаємо серверну ноду Eclair. Eclair - це проект з відкритим кодом, і його можна знайти на GitHub:

https://github.com/ACINQ/eclair


В наступних секціях ми створимо docker-контейнер для запуску Eclair, як ми робили раніше з c-lightning та LND. Ми також зберемо Eclair безпосередньо з вихідного коду.

==== Eclair у вигляді docker-конейтера

Ви вже майже експерт в основних операціях docker! У цій секції ми повторимо багато раніше використаних команд для створення контейнера Eclair. Контейнер знаходиться в +code/docker/eclair+. Ми починаємо з терміналу, переходимо в робочий каталог +code/docker+ і виконуємо команду +docker build+:

----
$ cd code/docker
$ docker build -t lnbook/eclair eclair
Sending build context to Docker daemon  9.216kB
Step 1/22 : FROM ubuntu:20.04 AS eclair-base
 ---> c3c304cb4f22
Step 2/22 : RUN apt update && apt install -yqq 	curl gosu jq bash-completion
 ---> Using cache
 ---> 3f020e1a2218
Step 3/22 : RUN apt update && apt install -yqq 	openjdk-11-jdk unzip
 ---> Using cache
 ---> b068481603f0

[...]

Step 22/22 : CMD ["/usr/local/bin/logtail.sh"]
 ---> Using cache
 ---> 5307f28ff1a0
Successfully built 5307f28ff1a0
Successfully tagged lnbook/eclair:latest

----

Тепер наш контейнер створено і він готовий до роботи. Перед запуском контейнера Eclair, нам треба запустити контейнер bitcoind в іншому терміналі, оскільки Eclair залежить від bitcoind. Ми вже створили мережу docker під назвою +lnbook+ і будемо використовувати її знову.

Одна важлива відмінність між Eclair та LND або c-lightning полягає в тому, що нода Eclair не містить в собі біткоїн-гаманця, натомість Eclair покладається на біткоїн-гаманець у Bitcoin Core. Нагадаємо, що використовуючи LND ми "профінансували" його біткоїн-гаманець, перевівши біткоїни з гаманця Bitcoin Core на гаманець LND. Цей крок зайвий у випадку Eclair. При запуску Eclair гаманець Bitcoin Core використовується безпосередньо як джерело коштів для відкриття каналів. В результаті, на відміну від контейнерів LND або c-lightning, контейнер Eclair не містить скрипта для переводу біткоїнів у свій гаманець при запуску.

==== Запуск контейнерів bitcoind і Eclair

Як і раніше, ми запускаємо контейнер bitcoind в одному терміналі і контейнер Eclair - в іншому. Якщо контейнер bitcoind вже запущено, то перезапускати його не потрібно. Просто залиште його запущеним і переходьте до наступного кроку. Щоб запустити +bitcoind+ в мережі +lnbook+, використаємо команду +docker run+ наступним чином:

----
$ docker run -it --network lnbook --name bitcoind lnbook/bitcoind
----

Далі запустимо щойно створений контейнер Eclair. Нам потрібно під'єднати його до мережі +lnbook+ і дати йому ім'я, як ми це робили з іншими контейнерами:

----
$ docker run -it --network lnbook --name eclair lnbook/eclair
Waiting for bitcoind to start...
Waiting for bitcoind to mine blocks...
Starting eclair...
Eclair node started
/usr/local/bin/logtail.sh
INFO  fr.acinq.eclair.Plugin$ - loading 0 plugins
INFO  a.e.slf4j.Slf4jLogger - Slf4jLogger started
INFO  fr.acinq.eclair.Setup - hello!
INFO  fr.acinq.eclair.Setup - version=0.4 commit=69c538e
[...]

----

Контейнер Eclair запускається і підключається до контейнера bitcoind через docker-мережу. Спочатку наша нода Eclair чекатиме на запуск bitcoind, а потім чекатиме поки bitcoind змайнить трохи біткоїнів у свій гаманець.

Як було показано раніше, ми можемо давати команди нашому контейнеру в іншому терміналі для отримання інформації, відкриття каналів тощо. Команда, що дозволяє нам давати інструкції демону +eclair+, називається +eclair-cli+. Команда +eclair-cli+ потребує пароль, який ми попередньо встановили на цьому контейнері у значення "eclair". Ми передаємо пароль +eclair+ в команду +eclair-cli+ через флаг +p+. За допомогою команди +docker exec+ в іншому терміналі ми отримуємо інформацію про ноду Eclair:

----
$ docker exec eclair eclair-cli -p eclair getinfo
{
  "version": "0.4-69c538e",
  "nodeId": "03ca28ed39b412626dd5efc514add8916282a1360556f8101ed3f06eea43d6561a",
  "alias": "eclair",
  "color": "#49daaa",
  "features": "0a8a",
  "chainHash": "06226e46111a0b59caaf126043eb5bbf28c34f3a5e332a1fc7b2b73cf188910f",
  "blockHeight": 123,
  "publicAddresses": []
}

----

Тепер у нас є ще одна Lightning-нода, яка працює в мережі +lnbook+ і спілкується з bitcoind. Ви можете запускати будь-яку кількість та будь-яку комбінацію нод Lightning в одній мережі Lightning. Будь-яка кількість нод Eclair, LND та c-lightning може співіснувати. Наприклад, щоб запустити другу ноду Eclair, виконайте команду +docker run+ з іншим ім'ям контейнера:

----
$ docker run -it --network lnbook --name eclair2 lnbook/eclair
----

Вищенаведеною командою ми запускаємо ще один контейнер Eclair під назвою +eclair2+.

У наступній секції ми також розглянемо, як завантажити, налаштувати та скомпілювати Eclair безпосередньо з вихідного коду. Це необов’язковий та просунутий крок, який навчить вас користуватися інструментами збірки мов Scala та Java та дозволить вам модифікувати вихідний код Eclair. Завдяки цим знанням ви зможете написати якийсь свій код чи виправити деякі помилки. Якщо ви не плануєте занурюватися у вихідний код або програмувати ноду Lightning, ви можете повністю пропустити наступну секцію. Щойно створений docker-контейнер буде цілком достатнім для більшості прикладів у книзі.

==== Інсталяція Eclair з вихідного коду

У цьому розділі ми зберемо Eclair з нуля. Eclair написаний мовою програмування Scala, яка компілюється за допомогою компілятора Java. Для запуску Eclair нам спочатку потрібно встановити Java та її інструменти збірки. Ми будемо слідувати інструкціям, наведеним у документі BUILD.md проекту Eclair:

https://github.com/ACINQ/eclair/blob/master/BUILD.md

Потрібний нам компілятор Java є частиною OpenJDK 11. Нам також знадобиться фреймворк для збірки під назвою Maven версії 3.6.0 або новішої.

У Debian/Ubuntu Linux ми можемо використати команду +apt+ для встановлення OpenJDK11 і Maven, як показано нижче:

----
$ sudo apt install -y openjdk-11-jdk maven
----

Переконайтесь, що правильна версія встановлена, запустивши:

----
$ javac -version
javac 11.0.7
$ mvn -v
Apache Maven 3.6.1
Maven home: /usr/share/maven
Java version: 11.0.7, vendor: Ubuntu, runtime: /usr/lib/jvm/java-11-openjdk-amd64

----

Ми маємо OpenJDK 11.0.7 та Maven 3.6.1, отже ми готові.

==== Копіювання вихідного коду Eclair

Вихідний код Eclair лежить на Github. Командою +git clone+ створимо його локальну копію. Перейдемо до нашого домашнього каталогу та запустимо її звідти:

----
$ cd ~
$ git clone https://github.com/ACINQ/eclair.git

----

Як тільки +git clone+ завершить свою роботу, у вас буде підкаталог +eclair+ з вихідним кодом серверу Eclair.

==== Компіляція вихідного коду Eclair

Eclair використовує систему збірки +Maven+. Для збірки проекту ми переходимо в каталог з вихідним кодом Eclair, а потім виконуємо команду +mvn package+:

----
$ cd eclair
$ mvn package
[INFO] Scanning for projects...
[INFO] ------------------------------------------------------------------------
[INFO] Reactor Build Order:
[INFO]
[INFO] eclair_2.13                                                        [pom]
[INFO] eclair-core_2.13                                                   [jar]
[INFO] eclair-node                                                        [jar]
[INFO] eclair-node-gui                                                    [jar]
[INFO]
[INFO] --------------------< fr.acinq.eclair:eclair_2.13 >---------------------
[INFO] Building eclair_2.13 0.4.1-SNAPSHOT                                [1/4]
[INFO] --------------------------------[ pom ]---------------------------------

[...]

[INFO] eclair_2.13 ........................................ SUCCESS [  3.032 s]
[INFO] eclair-core_2.13 ................................... SUCCESS [  7.935 s]
[INFO] eclair-node ........................................ SUCCESS [ 35.127 s]
[INFO] eclair-node-gui .................................... SUCCESS [ 20.535 s]
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time:  01:06 min
[INFO] Finished at: 2020-06-26T09:43:21-04:00
[INFO] ------------------------------------------------------------------------

----

Через кілька хвилин збірка пакета Eclair завершиться. Ви знайдете ноду Eclair у папці +eclair-node/target+ у вигляді zip-файлу. Розпакуйте та запустіть його, дотримуючись інструкції:

https://github.com/ACINQ/eclair#installing-eclair

Вітаємо! Ви зібрали Eclair з вихідного коду і тепер готові писати код, тестувати, виправляти помилки та робити свій внесок в цей проект!

=== Побудова цілої мережі різноманітних Lightning-нод

В останньому прикладі цього розділу ми об’єднаємо всі раніше створені контейнери і сформуємо мережу Lightning, яка складається з різноманітних реалізацій нод (LND, c-lightning, Eclair). Ми складемо мережу із з'єднаних між собою нод і відкриємо канали від однієї ноди до іншої. На останньому кроці ми відправимо платіж по цим каналам.

У цьому прикладі ми відтворимо приклад мережі Lightning із <<routing_on_a_network_of_payment_channels>>. Зокрема, ми створимо чотири Lightning-ноди з іменами Аліса, Боб, Вей та Глорія. Ми з'єднаємо Алісу з Бобом, Боба з Веєм, а Вея з Глорією. Нарешті, ми попросимо Глорію створити інвойс, а Аліса його сплатить. Оскільки Аліса та Глорія не будуть з'єднані безпосередньо, платіж буде відправлений як HTLC вздовж всіх платіжних каналів.

==== Використання docker-compose для організації контейнерів docker

Для роботи цього прикладу ми скористаємось інструментом _container orchestration_, що доступний за командою +docker-compose+. Ця команда дозволяє нам вказати застосунок, який складається з декількох контейнерів, і запустити його шляхом запуску всіх взаємодіючих між собою контейнерів разом.

Спочатку встановимо +docker-compose+. Інструкції зі встановлення залежать від вашої операційної системи, і їх можна знайти тут:

https://docs.docker.com/compose/install/

Після завершення встановлення ви можете перевірити успішність встановлення, запустивши docker-compose наступним чином:

----
$ docker-compose version
docker-compose version 1.21.0, build unknown
[...]

----

Найпоширенішими командами +docker-compose+, які ми будемо використовувати, є +up+ і +down+, наприклад +docker-compose up+.

==== Налаштування docker-compose

Файл налаштування +docker-compose+ знаходиться в каталозі +code/docker+ і називається +docker-compose.yml+. В ньому вказана назва мережі та перелік із чотирьох контейнерів. Початок файлу виглядає так:

----
version: "3.3"
networks:
  lnnet:

services:
  bitcoind:
    container_name: bitcoind
    build:
        context: bitcoind
    image: lnbook/bitcoind:latest
    networks:
      - lnnet
    expose:
      - "18443"
      - "12005"
      - "12006"

  Alice:
    container_name: Alice
----

Фрагмент вище визначає мережу під назвою +lnnet+ та контейнер з назвою +bitcoind+, який буде під'єднуватися до мережі +lnnet+. Контейнер +bitcoind+ - той самий, який ми створили на початку цього розділу. Ми відкриваємо три порти контейнера, що дозволить надсилати йому команди та моніторити блоки та транзакції. Далі конфігурація визначає контейнер LND під назвою "Аліса". Далі ви також побачите специфікації для контейнерів під назвами "Боб" (c-lightning), "Вей" (Eclair) і "Глорія" (знову LND).

Оскільки всі ці варіанти реалізації відповідають вимогам специфікації "Основи Технології Lightning" (BOLT) і були ретельно перевірені на сумісність, вони без проблем працюють разом для створення мережі Lightning.

==== Запуск прикладу мережі Lightning

Перш ніж розпочати, слід переконатися, що в нас не запущений жоден контейнер. Якщо новий контейнер має те саме ім'я, що і вже запущений, то його не вдасться запустити. За потреби використовуйте команди +docker ps+, +docker stop+ та +docker rm+, щоб зупинити та видалити запущені на даний момент контейнери!

[TIP]
====
Оскільки ми використовуємо однакові назви для цих організованих docker-контейнерів, можливо, нам доведеться зробити "зачистку", щоб уникнути будь-яких конфліктів імен.
====

Для запуску прикладу ми переходимо до каталогу, що містить конфігураційний файл +docker-compose.yml+, і виконуємо команду+docker-compose up+:

----
$ cd code/docker
$ docker-compose up
Creating network "docker_lnnet" with the default driver
Creating Wei      ... done
Creating Bob      ... done
Creating Gloria   ... done
Creating Alice    ... done
Creating bitcoind ... done
Attaching to Wei, Bob, Gloria, Alice, bitcoind
Bob         | Waiting for bitcoind to start...
Wei         | Waiting for bitcoind to start...
Alice       | Waiting for bitcoind to start...
Gloria      | Waiting for bitcoind to start...
bitcoind    | Starting bitcoind...

[...]
----

Після запуску ви побачите цілий потік логів, так як кожна із нод, що запускаються, повідомляє про свою роботу. На вашому екрані це може виглядати перемішаним, але кожен рядок виводу містить префікс з назвою контейнера, як показано вище. Якщо ви захочете переглянути лог лише з одного контейнера, то зможете зробити це в іншому терміналі за допомогою команди +docker-compose logs+ з флагом +f+ (_follow_) та ім'ям потрібного контейнера:

----
$ docker-compose logs -f Alice
----

==== Відкриття каналів та маршрутизація платежа

Тепер наша мережа Lightning має працювати. Як ви бачили в попередніх секціях цього розділу, ми можемо давати команди запущеному docker-контейнеру за допомогою команди +docker exec+. Незалежно від того, запустили ми контейнер за допомогою +docker run+ чи запустили групу контейнерів командою +docker-compose up+, ми все одно можемо взаємодіяти з кожним із контейнерів через команди docker.

Для спрощення у нас є маленький допоміжний скрипт, який налаштовує мережу, видає інвойс та здійснює платіж. Скрипт називається +setup-channels.sh+ і написаний мовою сценаріїв шеллу Bash. Майте на увазі, що цей скрипт не є надто вишуканим! Він "наосліп" кидає команди на різні ноди і не робить жодної перевірки помилок. Якщо мережа працює коректно і на нодах є кошти, то все це працює чудово. Однак вам доведеться трохи почекати, поки все завантажиться і буде змайнена певна кількість блоків. Зазвичай це займає від 1 до 3 хвилин. Як тільки ви побачите на кожній з нод блок висотою 102 або вище, скрипт готовий до запуску. Якщо скрипт не виконується, ви можете все зупинити (+docker-compose down+) і спробувати знову з самого початку. Або ви можете руками по черзі давати команди із Bash-скрипта та слідкувати за результатами.

[TIP]
====
Перед запуском скрипта +setup-channels.sh+ зверніть увагу на наступне: Зачекайте хвилину чи дві після запуску мережі за допомогою +docker-compose+, щоб переконатися, що всі служби працюють і на всіх гаманцях є кошти. Заради спрощення скрипт не перевіряє "готовність" контейнерів. Наберіться терпіння!
====

Давайте запустимо скрипт, щоб побачити його дію, а потім подивимось, як він працює зсередини. Ми використовуємо +bash+, щоб запустити скрипт:

----
$ cd code/docker
$ bash setup-channels.sh
Getting node IDs
Alice: 02c93da7a0a341d28e6d7742721a7d182f878e0c524e3666d80a58e1406d6d9391
Bob: 0343b8f8d27a02d6fe688e3596b2d0834c576672e8750106540617b6d5755c812b
Wei: 03e17cbc7b46d553bade8687310ee0726e40dfa2c629b8b85ca5d888257757edc1
Gloria: 038c9dd0f0153cba3089616836936b2dad9ea7f97ef839f5fbca3a808d232db77b

Setting up channels...
Alice to Bob

Bob to Wei

Wei to Gloria

Get 10k sats invoice from Gloria

Gloria invoice lnbcrt100u1p00w5sypp5fw2gk98v6s4s2ldfwxa6jay0yl3f90j82kv6xx97jfwpa3s964vqdqqcqzpgsp5jpasdchlcx85hzfp9v0zc7zqs9sa3vyasj3nm0t4rsufrl7xge6s9qy9qsqpdd5d640agrhqe907ueq8n8f5h2p42vpheuzen58g5fwz94jvvnrwsgzd89v70utn4d7k6uh2kvp866zjgl6g85cxj6wtvdn89hllvgpflrnex

Wait for channel establishment - 60 seconds for 6 blocks

----

Як видно з виводу, скрипт спочатку отримує ідентифікатори (відкриті ключі) кожної із чотирьох нод. Потім він з'єднує ноди і відкриває канали на 1,000,000 сатоші від кожної ноди до наступної.

Заглядаючи всередину скрипта, ми бачимо ту частину, яка отримує всі ідентифікатори нод і зберігає їх у тимчасових змінних, щоб можна було використовувати їх далі. Це виглядає так:

----
alice_address=$(docker-compose exec -T Alice bash -c "lncli -n regtest getinfo | jq .identity_pubkey")
bob_address=$(docker-compose exec -T Bob bash -c "lightning-cli getinfo | jq .id")
wei_address=$(docker-compose exec -T Wei bash -c "eclair-cli -s -j -p eclair getinfo| jq .nodeId")
gloria_address=$(docker-compose exec -T Gloria bash -c "lncli -n regtest getinfo | jq .identity_pubkey")
----

Якщо ви були уважні в першій частині розділу, ви впізнаєте ці команди і зможете "розшифрувати" їх значення. Це виглядає дещо складним, але ми пройдемося покроково, і ви все швидко зрозумієте.

Перша команда вносить результат команди +docker-compose exec+ у змінну +alice_address+. Флаг +T+ вказує +docker-compose+ не відкривати інтерактивний термінал, так як він може намішати у вивід такі речі, як кольорове кодування. Команда +exec+ спрямована контейнеру +Alice+ і запускає утиліту +lncli+, оскільки +Alice+ є нодою LND. Команді +lncli+ слід вказати, що вона працює в мережі +regtest+, і що вона має виконати команду +getinfo+. Вивід +getinfo+ є закодованим JSON-об'єктом, який ми можемо розпарсити, передавши його команді +jq+ через пайп. Команда +jq+ бере поле +identity_pubkey+ з JSON-об'єкта. Потім вміст поля +identity_pubkey+ виводиться і зберігається в змінній +alice_address+.

Наступні три рядки виконують те ж саме для інших нод. Оскільки це інші реалізації нод (c-lightning, Eclair), їхній інтерфейс командного рядка дещо відрізняється, але загальний принцип однаковий: за допомогою утиліти командної строки запитати у ноди інформацію про її відкритий ключ (ідентифікатор ноди), витягнути ідентифікатор за допомогою +jq+ та зберегти його у змінній для подальшого використання.

Далі ми вказуємо кожній ноді встановити мережеве з'єднання з наступною нодою і відкрити канал:

----
docker-compose exec -T Alice lncli -n regtest connect ${bob_address//\"}@Bob
docker-compose exec -T Alice lncli -n regtest openchannel ${bob_address//\"} 1000000
----

Обидві команди відносяться до контейнера +Alice+, оскільки канал буде відкритий _від_ +Alice+ _до_ +Bob+, тому +Alice+ ініціює підключення.

Як бачимо, у першій команді ми наказуємо +Alice+ підключитися до ноди +Bob+. Ідентифікатор ноди +Bob+ зберігається в +${bob_address}+, а її IP-адресу можна дізнатись по імені +Bob+, отже +@Bob+ використовується в якості мережевого ідентифікатора/адреси. Нам не потрібно вказувати номер порту (9375), оскільки ми використовуємо порти Lightning за замовчуванням.

Тепер коли нода +Alice+ підключена до ноди +Bob+, ми відкриваємо канал на 1,000,000 сатоші до +Bob+ командою +openchannel+. Ми посилаємось на ноду +Bob+ за ідентифікатором ноди, тобто за відкритим ключем.

Ми робимо те ж саме з іншими нодами - налаштовуємо мережеві з'єднання та канали. Кожен тип ноди має дещо відмінний синтаксис команд, але загальний принцип однаковий:

Ноді Боба (c-lightning) ми надсилаємо наступні команди:
----
docker-compose exec -T Bob lightning-cli connect ${wei_address//\"}@Wei 
docker-compose exec -T Bob lightning-cli fundchannel ${wei_address//\"} 1000000
----

Ноді Вея (Eclair) ми надсилаємо:
----
docker-compose exec -T Wei eclair-cli -p eclair connect --uri=${gloria_address//\"}@Gloria
docker-compose exec -T Wei eclair-cli -p eclair open --nodeId=${gloria_address//\"} --fundingSatoshis=1000000
----

Тепер ми створимо новий інвойс на 10,000 сатоші на ноді Глорії:

----
gloria_invoice=$(docker-compose exec -T Gloria lncli -n regtest addinvoice 10000 | jq .payment_request)
----

Команда +addinvoice+ створює інвойс на вказану суму в сатоші і видає JSON-об'єкт з деталями інвойса. З цього JSON-об’єкта нам потрібен лише закодований у bech32 запит на оплату, який ми дістаємо за допомогою +jq+.

Далі нам слід зачекати. Ми щойно створили купу каналів, тому наші вузли наразі транслюють по мережі кілька транзакцій фінансування. Каналами не можна користуватися, доки транзакції фінансування не будуть змайнені та не отримають 6 підтверджень. Оскільки наш +regtest+ Біткоїн-блокчейн налаштований на майнинг блоків кожні десять секунд, нам доведеться зачекати 60 секунд, поки всі канали будуть готові до використання.

Фінальною командою є сплата інвойсу. Ми підключаємось до ноди Аліси і надаємо їй інвойс Глорії для оплати.

----
docker-compose exec -T Alice lncli -n regtest payinvoice --json --inflight_updates -f ${gloria_invoice//\"}
----

Ми просимо ноду Аліси оплатити інвойс, а також просимо видати +inflight_updates+ у форматі +json+. Це дасть нам детальну інформацію про інвойс, маршрут, HTLC та остаточний результат оплати. Ми можемо вивчити цей додатковий вивід і повчитися на ньому!

Оскільки нода Аліси не має прямого каналу до Глорії, її нода має знайти маршрут. Тут є лише один життєздатний маршрут (Аліса->Боб->Вей->Глорія), який Аліса зможе знайти, коли всі канали активні і анонсовані всім нодам за протоколом пліток Lightning. Нода Аліси побудує маршрут і створить цибулевий пакет для встановлення HTLC вздовж каналів. Все це відбувається за долю секунди, і нода Аліси повідомить результат спроби оплати. Якщо все піде добре, ви побачите останній рядок JSON виводу:

----
"failure_reason": "FAILURE_REASON_NONE"
----

Безперечно, це дивне повідомлення, але той факт, що не було причини невдачі, означає, що операція пройшла успішно!

Проскроливши вище цього незвичного повідомлення, ви побачите всі деталі платежу. Там є багато речей для розгляду, але по мірі розуміння технології, що лежить в основі, все більше з тієї інформації стане зрозумілим. Пропонуємо переглянути цей приклад пізніше.

Звісно, за допомогою нашої тестової мережі ви можете зробити набагато більше, ніж платіж через 3 канали і 4 ноди. Ось кілька ідей для експериментів:

* Створіть більш складну мережу, запустивши набагато більше нод різних типів. Відредагуйте файл +docker-compose.yml+ та скопіюйте секції, перейменувавши контейнери за необхідності.

* З'єднуйте ноди в більш складні топології: кільцеві маршрути, зірка або сітка.

* Проведіть багато платежів, щоб виснажити місткість каналу. Потім виконайте платежі в зворотному напрямку, щоб збалансувати канали. Подивіться, як адаптується алгоритм маршрутизації.

* Змініть комісії каналу, щоб побачити, як алгоритм маршрутизації обирає серед кількох маршрутів і які оптимізації застосовує. Що краще - дешевий довгий маршрут чи дорогий короткий?

* Запустіть кільцевий платіж від ноди назад до себе, щоб збалансувати власні канали. Подивіться, як це впливає на всі інші канали та ноди.

* Генеруйте сотні або тисячі маленьких інвойсів у циклі, а потім сплачуйте їх якнайшвидше в іншому циклі. Виміряйте, скільки транзакцій в секунду ви зможете виконати у цій тестовій мережі.

=== Висновок

У цьому розділі ми розглянули різні проекти, які реалізують специфікації BOLT. Ми створили контейнери для запуску тестової мережі Lightning і навчилися збирати кожен проект із вихідного коду. Тепер ви готові досліджувати далі і копати глибше.