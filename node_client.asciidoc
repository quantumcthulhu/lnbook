[[set_up_a_lightning_node]]
== Софт для нод Lightning

Як ми побачили в попередніх розділах, нода Lightning - це комп’ютерна система, яка бере участь у мережі Lightning. Мережа Lightning - це не продукт чи компанія, це набір відкритих стандартів, які визначають основную лінію взаємодії. Тому програмне забезпечення для Lightning-нод розробляється різними компаніями та спільнотами. Переважна більшість софту для Lightning - з _відкритим кодом_, тобто має відкритий вихідний код і таку ліцензію, що дозволяє співпрацю, спільний доступ та участь спільноти в процесі розробки. Так само і реалізації нод Lightning, які ми представимо в цьому розділі, мають відкритий код і розроблені спільними зусиллями.

На відміну від Біткоїна, де стандарт визначається _еталонною реалізацією_ в програмному забезпеченні (Bitcoin Core), у Lightning стандарт визначається низкою документів, що називаються _Basis of Lightning Technology (BOLT)_ і знаходяться у репозиторії _lightning-rfc_ за адресою:

https://github.com/lightningnetwork/lightning-rfc

Не існує еталонної реалізації Lightning Network, але є декілька конкуруючих, сумісних з BOLT та інтероперабільних реалізацій, розроблених різними командами та організаціями. Команди, які розробляють програмне забезпечення для Lightning Network, також роблять свій внесок у розробку та еволюцію стандартів BOLT.

Інша велика відмінність між програмним забезпеченням нод Lightning та  нод Біткоїн полягає в тому, що ноди Lightning не мають йти в ногу з правилами консенсусу і можуть мати розширену функціональність за рамками BOLT. Тому різні команди можуть застосовувати різні експериментальні фічі, які пізніше в разі успіху та широкого використання можуть стати частиною BOLT.

У цьому розділі ви дізнаєтесь, як налаштувати кожний з програмних пакетів для найпопулярніших реалізацій ноди Lightning. Ми подали їх в алфавітному порядку, щоб підкреслити, що ми не надаємо переваги жодному із них. Кожен із них має свої сильні та слабкі сторони, і вибір програмного пакету буде залежати від різних факторів. Оскільки вони написані на різних мовах програмування (наприклад Go, C і т.д.), ваш вибір також може залежати від рівня обізнаності в певній мові та в інструментах розробки.

=== Середовище Розробки Lightning

((("development environment", "setup")))Якщо ви розробник, то скоріш за все захочете створити середовище розробки з усіма інструментами, бібліотеками та іншим софтом для написання та запуску софту Lightning. У цій дуже технічній главі ми пройдемося по цьому процесу крок за кроком. Якщо матеріал здається вам занадто глибоким або ви не бажаєте налаштовувати середовище розробки, сміливо переходьте до наступної менш технічної глави.

==== Використання командного рядку

У прикладах цього розділу та в цілому у книзі використовується командний рядок. Це означає, що ви вводите команди в термінал і отримуєте текстові відповіді. Крім того, приклади продемонстровано на операційній системі Linux, останньому стабільному дистрибутиві Ubuntu (Ubuntu 20.04 LTS). Більшість прикладів можна відтворити в інших операційних системах, таких як Windows або Mac OS, з невеликою різницею в командах. Найбільша різниця між операційними системами - це _пакетний менеджер_, який встановлює різні бібліотеки програмного забезпечення та їх залежності. У наших прикладах ми будемо використовувати +apt+, менеджер пакетів для Ubuntu. У Mac OS загальним менеджером пакетів, що використовується для розробки з відкритим кодом, є Homebrew (команда +brew+), який можна знайти за адресою https://brew.sh.

У більшості прикладів ми будемо збирати програмне забезпечення прямо з вихідного коду. Хоча це може бути досить складним завданням, але це дає нам найбільше влади та контролю. Ви можете замість цього використовувати docker-контейнери, пре-компільовані пакети та інші механізми інсталяції, якщо застрягнете!

[TIP]
====
((("$ symbol")))((("shell commands")))((("terminal applications")))У багатьох прикладах цього розділу ми будемо використовувати інтерфейс командного рядка операційної системи (також відомий як "шелл"), доступ до якого здійснюється через програму-термінал. Спочатку шелл відобразить запрошення вводу як індикатор готовності до вашої команди. Потім ви вводите команду і натискаєте "Enter", на яку шелл відповідає деяким текстом і новим запитом вашої наступної команди. Запит може виглядати по-різному у вашій системі, але далі в прикладах він позначатиметься символом +$+. У прикладах, коли ви бачите текст після символу +$+, не вводьте символ +$+, а лише команду, яка слідує за ним. Потім натисніть клавішу Enter, щоб виконати команду. У наведених прикладах рядки, розташовані під кожною командою - це відповіді операційної системи на цю команду. Коли ви побачите наступний префікс +$+, ви зрозумієте, що це нова команда, і вам слід повторити процес.
====

Для сумісності в усіх прикладах з командним рядком ми використовуємо шелл +bash+. Хоча інші шелли працюватимуть в аналогічний спосіб, деякі скрипти написані спеціально для +bash+ і при запуску в іншому шеллі вимагатимуть деяких модифікацій. Для сумісності ви можете інсталювати +bash+ шелл на Windows або Mac OS, а на більшості Linux систем він встановлений за замовчуванням.

==== Скачування репозиторію книги

Всі приклади доступні в онлайн репозиторії книги. Оскільки онлайн репозиторій буде постійно утримуватися в актуальному стані наскільки це можливо, ви завжди зможете знайти там останню версію замість копіювання прикладів із книги.

Щоб скачати репозиторій у вигляді ZIP архіву, відкрийте +github.com/lnbook/lnbook+ і оберіть справа зелену кнопку з написом "Clone or Download".

Також ви можете скористатися командоюю +git+, щоб склонувати репозиторій на свій комп'ютер. Git - це розподілена система контроля версій, що використовується більшістю розробників для спільної розробки програмного забезпечення або відслідковування змін до репозиторіїв. Скачайте та інсталюйте +git+ за інструкцією на https://git-scm.com/

Щоб скопіювати репозиторій на свій комп'ютер, виконайте команду git наступним чином:

[git-clone-lnbook]
----
$ git clone git@github.com:lnbook/lnbook.git
----

Тепер у вас є повна копія репозиторію книги у папці +lnbook+. Всі наступні команди передбачають, що ви запускаєте команди з цієї папки.

=== Контейнери Docker

Більшість розробників використовуєть _контейнери_ - це різновид віртуальної машини, що містить попередьно налаштовану операційну систему та встановлені програми зі всіма необхідними залежностями. Більшість софту Lightning також може бути інстальовано з використанням системи контейнерів на зразок _Docker_ (команда +docker+), яку можна знайти на сайті https://docker.com. Встановлення контейнерів значно простіше, особливо для тих, кто не звик до командного рядка.

Репозиторій книги містить колекцію контейнерів docker, які можна використати для встановлення сумісного середовища розробки, щоб практикуватись і повторювати приклади на будь-якій системі. Завдяки тому, що контейнер - ці ціла операційна система, що має сумісну конфігурацію, ви можете бути впевнені, що приклади працюватимуть на вашому комп'ютері і не хвилюватись щодо залежностей, версій бібліотек або різниці в налаштуваннях.

Контейнери docker найчастіше налаштовані так, щоб бути невеликими, тобто займати мінімум дискового простору. Проте в цій книзі ми використовуємо контейнери для того, щоб _стандартизувати_ середовище і зробити його сумісним для всіх читачів. Крім того, ці контейнери не мають використовуватися для запуску сервісів у бекграунді. Замість цього вони мають використовуватися для тестування прикладів і вивчення взаємодії з софтом. Через це контейнери мають досить великий розмір і містять багато інструментів розробки та утиліт. Зазвичай для зменшення розміру у Linux-контейнерах використовується дистрибутив Alpine. Однак ми використовуємо контейнери на Ubuntu через те, що більшість розробників добре знайомі з Ubuntu, і це для нас важливіше за розмір. 

Ви можете знайти останні конфігурації контейнерів в репозиторії книги у папці +code/docker+. Кожен контейнер знаходиться в окремій папці як видно нижче:

//// $ tree -F --charset=asciii  code
[docker-dir-list]
----
code
`-- docker/
    |-- bitcoind/
    |   |-- bashrc
    |   |-- bitcoind/
    |   |   |-- bitcoin.conf
    |   |   `-- keys/
    |   |       |-- demo_address.txt
    |   |       |-- demo_mnemonic.txt
    |   |       `-- demo_privkey.txt
    |   |-- bitcoind-entrypoint.sh
    |   |-- Dockerfile
    |   `-- mine.sh*
    |-- c-lightning/
    |   |-- bashrc
    |   |-- c-lightning-entrypoint.sh
    |   |-- Dockerfile
    |   |-- fund-c-lightning.sh
    |   |-- lightningd/
    |   |   `-- config
    |   |-- logtail.sh
    |   `-- wait-for-bitcoind.sh
    |-- eclair/
    |   |-- bashrc
    |   |-- Dockerfile
    |   |-- eclair/
    |   |   `-- eclair.conf
    |   |-- eclair-entrypoint.sh
    |   |-- logtail.sh
    |   `-- wait-for-bitcoind.sh
    |-- lnbook-app/
    |   |-- docker-compose.yml
    |   `-- setup-channels.sh
    `-- lnd/
        |-- bashrc
        |-- Dockerfile
        |-- fund-lnd.sh
        |-- lnd/
        |   `-- lnd.conf
        |-- lnd-entrypoint.sh
        |-- logtail.sh
        `-- wait-for-bitcoind.sh
----

==== Інсталяція Docker

Перед початком вам слід встановити систему контейнерів docker на свій комп’ютер. Docker - це відкрита система, яка безкоштовно розповсюджується як _Community Edition_ для багатьох операційних систем, включаючи Windows, Mac OS та Linux. Версії для Windows та Mac називаються _Docker Desktop_ і складаються з віконної програми та інструментів командного рядка. Версія для Linux називається _Docker Engine_ і складається з демона-сервера та інструментів командного рядка. Ми будемо використовувати ідентичні на всіх платформах інструменти командного рядка.

Встановіть Docker для вашої операційної системи, дотримуючись інструкцій _"Get Docker"_ з веб-сайту Docker за адресою:

https://docs.docker.com/get-docker/

Оберіть зі списку свою операційну систему та дотримуйтесь інструкцій із встановлення.

[TIP]
====
Якщо ви інсталюєте на Linux, дотримуйтесь інструкцій пост-інсталяції, щоб переконатися, що ви можете запускати Docker як звичайний користувач замість користувача _root_. Інакше вам потрібно буде додати до всіх команд +docker+ префікс +sudo+ для їх виконання з правами root: +sudo docker+.
====

Після встановлення Docker ви можете протестувати установку, запустивши демонстраційний контейнер +hello-world+ наступним чином:

[docker-hello-world]
----
$ docker run hello-world

Hello from Docker!
This message shows that your installation appears to be working correctly.

[...]
----

==== Базові команди docker

У цьому розділі ми досить широко використовуємо +docker+. Ми будемо використовувати наступні команди та аргументи +docker+:

*Збірка контейнера*

----
docker build [-t tag] [directory]
----

...де +tag+ - це ідентифікатор контейнера, який ми збираємо, а +directory+ - це папка, де знаходяться "контекст" контейнера (папки та файли) та файл визначення (+Dockerfile+).

*Запуск контейнера*

----
docker run -it [--network netname] [--name cname] tag
----

...де +netname+ - це назва мережі docker, +cname+ - це назва, яку ми даємо цьому екземпляру контейнера, а +tag+ - це тег імені, яке ми дали контейнеру при його зборці.

*Запуск команди в контейнері*

----
docker exec cname command
----

...де +cname+ - це ім’я, яке ми дали контейнеру в команді +run+, а +command+ - це програма або скрипт, який ми хочемо запустити всередині контейнера.

*Зупинення контейнера*

У більшості випадків, коли ми запускаємо контейнер у режимі _interactive_ та _terminal_, тобто з флагами +i+ та +t+ (що об'єднані у вигляді +-it+), контейнер можна зупинити, просто натиснувши +CTRL-C+ або вийшовши з оболонки за допомогою команди +exit+ або натиснувши +CTRL-D+. Якщо контейнер не припиняє роботу, ви можете зупинити його з іншого терміналу наступним чином:

----
docker stop cname
----

...де +cname+ це ім'я, яке ми дали контейнеру при запуску.

*Видалення контейнеру по імені*

Якщо ви даєте контейнеру ім'я замість того, щоб docker назвав його випадковим чином, ви не зможете повторно використовувати це ім'я, поки контейнер не буде видалено. У цьому випадку Docker поверне наступну помилку:
----
docker: Error response from daemon: Conflict. The container name "/bitcoind" is already in use...
----

Щоб виправити це, видаліть існуючий екземпляр контейнера:

----
docker rm cname
----

...де +cname+ - ім'я, присвоєне контейнеру (в прикладі з помилкою: +bitcoind+)

*Перелік запущених контейнерів*

----
docker ps
----

Цих основних команд docker вистачить для початку, вони дозволять вам запустити всі приклади з цього розділу. Давайте розглянемо їх у дії в наступних розділах.

=== Bitcoin Core і Regtest

Для роботи більшості реалізацій Lightning-нод потрібен доступ до повної ноди Біткоїн.

Встановлення повної Біткоїн-ноди та синхронізація блокчейну Біткоїну виходить за рамки цієї книги і само по собі є відносно складною справою. Якщо ви хочете спробувати, зверніться до _Mastering Bitcoin_ (https://github.com/bitcoinbook/bitcoinbook), "Chapter 3: Bitcoin Core: The Reference Implementation", де обговорюється встановлення та робота ноди Біткоїн.

Нода Біткоїн здатна працювати в режимі _regtest_, при якому нода локально створює тестову симуляцію блокчейна Біткоїна. У наступних прикладах ми будемо використовувати режим +regtest+, що дозволить нам продемонструвати Lightning без необхідності мати синхронізовану Біткоїн-ноду і без потреби ризикувати будь-якими коштами.

Контейнером для Bitcoin Core є +bitcoind+. Він налаштований на запуск Bitcoin Core в режимі +regtest+ та майнинг нового блоку кожні 10 секунд. RPC знаходиться на порту 18443, ім'я користувача +regtest+, пароль +regtest+. Також ви можете отримати доступ до RPC за допомогою інтерактивного шеллу та запускати команди +bitcoin-cli+ локально.

===== Збірка контейнера Bitcoin Core

Почнемо з збірки та запуску контейнера +bitcoind+. Спочатку виконаємо команду +docker build+:

----
$ cd code/docker
$ docker build -t lnbook/bitcoind bitcoind
Sending build context to Docker daemon  12.29kB
Step 1/25 : FROM ubuntu:20.04 AS bitcoind-base
 ---> c3c304cb4f22
Step 2/25 : RUN apt update && apt install -yqq 	curl gosu jq bash-completion

[...]

Step 25/25 : CMD ["/usr/local/bin/mine.sh"]
 ---> Using cache
 ---> 758051998e72
Successfully built 758051998e72
Successfully tagged lnbook/bitcoind:latest
----

===== Запуск контейнера Bitcoin Core

Далі запустимо контейнер +bitcoind+ і дозволимо йому змайнити кілька блоків. Ми використовуємо команду +docker run+ із флагами _interactive (i)_ та _terminal (t)_, а також аргументом +name+, щоб надати запущеному контейнеру власне ім'я:

----
$ docker run -it --name bitcoind lnbook/bitcoind
Starting bitcoind...
Bitcoin Core starting
bitcoind started
================================================
Importing demo private key
Bitcoin address:  2NBKgwSWY5qEmfN2Br4WtMDGuamjpuUc5q1
Private key:  cSaejkcWwU25jMweWEewRSsrVQq2FGTij1xjXv4x1XvxVRF1ZCr3
================================================

Mining 101 blocks to unlock some bitcoin
[
  "579311009cc4dcf9d4cc0bf720bf210bfb0b4950cdbda0670ff56f8856529b39",
 ...
  "33e0a6e811d6c49219ee848604cedceb0ab161485e1195b1f3576049e4d5deb7"
]
Mining 1 block every 10 seconds
[
  "5974aa6da1636013daeaf730b5772ae575104644b8d6fa034203d2bf9dc7a98b"
]
Balance: 100.00000000
----

Як бачимо, bitcoind запускається і майнить 101 блок. Це пов’язано із тим, що згідно правил консенсусу Біткоїна, щойно видобуті біткоїни не можуть бути витрачені, поки не пройде 100 блоків. Змайнивши 101-ший блок, стає можливим витратити біткоїни, створені у блоці 1. Після цього початкового майнингу новий блок буде майнитись кожні 10 секунд.

На даний момент транзакцій немає (прим.перекл.: окрім coinbase-транзакцій). Але у нас в гаманці є кілька змайнених тестових біткоїнів, які ми можемо витратити. Коли ми підключимо декілька Lightning-нод, ми відправимо до їх гаманців трохи біткоїнів, щоб потім відкрити декілька платіжних каналів між цими Lightning-нодами.

===== Взаємодія з контейнером Bitcoin Core

Ми також можемо взаємодіяти з контейнером +bitcoind+, надсилаючи йому команди шеллу. Контейнер надсилає лог-файл в термінал, відображаючи процес майнингу, що відбувається у bitcoind. Для взаємодії з шеллом ми можемо писати команди в іншому терміналі, використовуючи команду +docker exec+. Оскільки раніше ми дали назву запущеному контейнеру за допомогою аргумента +name+, то ми можемо посилатися на нього за цим ім'ям, коли запускаємо команду +docker exec+. Запустимо спочатку інтерактивний шелл +bash+:

----
$ docker exec -it bitcoind /bin/bash
root@e027fd56e31a:/bitcoind# ps x
  PID TTY      STAT   TIME COMMAND
    1 pts/0    Ss+    0:00 /bin/bash /usr/local/bin/mine.sh
    7 ?        Ssl    0:03 bitcoind -datadir=/bitcoind -daemon
   97 pts/1    Ss     0:00 /bin/bash
  124 pts/0    S+     0:00 sleep 10
  125 pts/1    R+     0:00 ps x
root@e027fd56e31a:/bitcoind#
----

Запуск інтерактивного шеллу пускає нас "всередину" контейнера. Ми логінимось від імени користувача +root+, як видно з префікса +root@+ у підказці нового шеллу: +root@e027fd56e31a:/bitcoind#+. Якщо ми дамо команду +ps x+, то побачимо запущені у бекграунді процеси +bitcoind+ і +mine.sh+. Для виходу із цього шеллу, натисніть +CTRL-D+ або введіть +exit+, і ви повернетесь до шеллу вашої операційної системи.

Замість запуску інтерактивного шеллу ми також можемо дати команду, яка буде виконана всередині контейнера. У наступному прикладі ми запускаємо команду +bitcoin-cli+, щоб отримати інформацію про поточний стан блокчейну:

----
$ docker exec bitcoind bitcoin-cli -datadir=/bitcoind getblockchaininfo
{
  "chain": "regtest",
  "blocks": 149,
  "headers": 149,
  "bestblockhash": "35e97bf507607be010be1daa10152e99535f7b0f9882d0e588c0037d8d9b0ba1",
  "difficulty": 4.656542373906925e-10,
 [...]
  "warnings": ""
}
$
----

Як бачите, нам потрібно вказати для +bitcoin-cli+ шлях до каталогу даних bitcoind за допомогою аргументу +datadir+. Потім ми можемо давати ноді Bitcoin Core RPC-команди і отримувати результати їх роботи у форматі JSON.

Всі наші docker-контейнери мають попередньо встановлений консольний кодер/декодер JSON під назвою +jq+. +jq+ допомагає нам обробляти дані у форматі JSON у консолі або із скриптів. Ви можете надіслати JSON-вивід будь-якої команди до +jq+, використовуючи символ +|+. Цей символ, а також цю операцію називають пайп ("pipe", що означає "труба"). Давайте застосуємо +пайп+ та +jq+ до попередньої команди наступним чином:

----
$ docker exec bitcoind bash -c "bitcoin-cli -datadir=/bitcoind getblockchaininfo | jq .blocks"
189
----

Команда +jq .blocks+ вказує JSON-декодеру +jq+ витягнути поле +blocks+ з результату команди +getblockchaininfo+. В нашому випадку вона витягує та друкує значення 189, яке ми можемо використати в наступній команді.

Як ви побачите в наступних розділах, ми можемо запускати кілька контейнерів одночасно, а потім взаємодіяти з ними окремо. Ми можемо подавати команди для отримання такої інформації, як відкритий ключ ноди Lightning, або для виконання таких дій, як відкриття каналу до іншої ноди. Команди +docker run+ та +docker exec+ разом із +jq+ для декодування JSON - це все, що нам треба для побудови робочої мережі Lightning, що поєднує різні імплементації нод. Це дозволяє нам провести різноманітні експерименти на власному комп’ютері.

=== Lightning-нода c-lightning

C-lightning - це легка, просто настроювана і сумісна зі стандартом реалізація протоколу Lightning Network, розроблена компанією Blockstream в рамках проекту Elements. Цей проект відкритий і спільно розробляється на Github:

https://github.com/ElementsProject/lightning

В наступних розділах ми зробимо docker-контейнер з нодою c-lightning, яка підключається до створеного раніше контейнера bitcoind. Ми також покажемо, як налаштувати та зібрати c-lightning безпосередньо з вихідного коду.

==== c-lightning у вигляді docker-контейнера

Поставка програмного забезпечення c-lightning має свій docker-контейнер, але він призначений для запуску c-lightning "на продакшені". Для демонстраційних цілей ми використаємо дещо простіший контейнер c-lightning.

Почнемо зі створення контейнера докера c-lightning з файлів книги, які ви раніше завантажили в каталог з іменем +lnbook+. Як і раніше, ми будемо використовувати команду +docker build+ у підкаталозі +code/docker+. Позначимо контейнер тегом +lnbook/c-lightning+ наступним чином:
----
$ cd code/docker
$ docker build -t lnbook/c-lightning c-lightning
Sending build context to Docker daemon  10.24kB
Step 1/21 : FROM lnbook/bitcoind AS c-lightning-base
 ---> 758051998e72
Step 2/21 : RUN apt update && apt install -yqq 	software-properties-common

[...]

Step 21/21 : CMD ["/usr/local/bin/logtail.sh"]
 ---> Using cache
 ---> e63f5aaa2b16
Successfully built e63f5aaa2b16
Successfully tagged lnbook/c-lightning:latest
----

Тепер наш контейнер створено і він готовий до роботи. Перед запуском контейнера c-lightning, нам треба запустити контейнер bitcoind в іншому терміналі, оскільки c-lightning залежить від bitcoind. Нам також потрібно буде створити мережу docker, яка дозволяє контейнерам з'єднатись між собою так, ніби вони розташовані в одній локальній мережі.

[TIP]
====
Контейнери docker можуть "спілкуватися" між собою через віртуальну локальну мережу під управлінням системи docker. Кожен контейнер може мати власне ім'я, а інші контейнери можуть використовувати це ім'я для визначення його IP-адреси та підключення.
====

==== Налаштування мережі docker

Як тільки мережа docker налаштована, docker активуватиме мережу на нашому локальному комп’ютері під час кожного запуску, наприклад після перезавантаження комп'ютера. Тому нам потрібно одноразово налаштувати мережу за допомогою команди +docker network create+. Сама назва мережі не має значення, але вона повинна бути унікальною на нашому комп’ютері. За замовчуванням docker має три мережі з іменами +host+, +bridge+ та +none+. Ми назвемо нашу нову мережу +lnbook+ і створимо її наступним чином:

----
$ docker network create lnbook
ad75c0e4f87e5917823187febedfc0d7978235ae3e88eca63abe7e0b5ee81bfb
$ docker network ls
NETWORK ID          NAME                DRIVER              SCOPE
7f1fb63877ea        bridge              bridge              local
4e575cba0036        host                host                local
ad75c0e4f87e        lnbook              bridge              local
ee8824567c95        none                null                local
----

Як ви можете бачити, команда +docker network ls+ видає нам перелік мереж docker. Нашу мережу +lnbook+ створено. Ми можемо ігнорувати ідентифікатор мережі, так як він використовується автоматично.

==== Запуск контейнерів bitcoind і c-lightning

Наступним кроком є запуск контейнерів bitcoind і c-lightning та підключення їх до мережі +lnbook+. Щоб запустити контейнер у певній мережі, ми повинні додати аргумент +network+ до команди +docker run+. Щоб контейнери могли легко знаходити один одного, ми дамо кожному із них ім'я за допомогою аргументу +name+. Ми запускаємо bitcoind наступним чином:

----
$ docker run -it --network lnbook --name bitcoind lnbook/bitcoind
----

Ви маєте побачити, як запускається bitcoind і починається майнинг блоків кожні 10 секунд. Залиште його запущеним і відкрийте нове вікно терміналу для запуску c-lightning. Ми використовуємо подібну команду +docker run+ з аргументами +network+ та +name+ для запуску c-lightning наступним чином:

----
$ docker run -it --network lnbook --name c-lightning lnbook/c-lightning
Waiting for bitcoind to start...
Waiting for bitcoind to mine blocks...
Starting c-lightning...
[...]
Startup complete
Funding c-lightning wallet
{"result":"e1a392ce2c6af57f8ef1550ccb9a120c14b454da3a073f556b55dc41592621bb","error":null,"id":"c-lightning-container"}
[...]
2020-06-22T14:26:09.802Z DEBUG lightningd: Opened log file /lightningd/lightningd.log

----

Контейнер c-lightning запускається і підключається до контейнера bitcoind через мережу docker. Спочатку наша нода c-lightning чекатиме на запуск bitcoind, а потім чекатиме поки bitcoind змайнить трохи біткоїнів у свій гаманець. Нарешті, в ході запуску контейнера, скрипт надішле bitcoind-ноді RPC-команду створення транзакції, яка переводить на гаманець c-lightning 10 тестових BTC. Наразі наша нода c-lightning не лише працює, але й навіть володіє кількома тестовими біткоїнами, якими можна погратись!

Як було показано на контейнері bitcoind, ми можемо давати команди нашому контейнеру c-lightning в іншому терміналі для отримання інформації, отримання переліку відкритих каналів тощо. Команда, що дозволяє нам давати інструкції ноді c-lightning, називається +lightning-cli+. Щоб отримати інформацію про ноду, виконайте наступну команду +docker exec+ в іншому вікні терміналу:

----
$ docker exec c-lightning lightning-cli getinfo
{
   "id": "025656e4ef0627bc87638927b8ad58a0e07e8d8d6e84a5699a5eb27b736d94989b",
   "alias": "HAPPYWALK",
   "color": "025656",
   "num_peers": 0,
   "num_pending_channels": 0,
   "num_active_channels": 0,
   "num_inactive_channels": 0,
   "address": [],
   "binding": [
      {
         "type": "ipv6",
         "address": "::",
         "port": 9735
      },
      {
         "type": "ipv4",
         "address": "0.0.0.0",
         "port": 9735
      }
   ],
   "version": "0.8.2.1",
   "blockheight": 140,
   "network": "regtest",
   "msatoshi_fees_collected": 0,
   "fees_collected_msat": "0msat",
   "lightning-dir": "/lightningd/regtest"
}

----

Тепер у нас є перша Lightning-нода, який працює у віртуальній мережі та спілкується з тестовим Біткоїн-блокчейном. Далі в цьому розділі ми запустимо більше нод, з'єднаємо їх між собою і проведемо кілька Lightning-платежів.

У наступній секції ми також розглянемо, як завантажити, налаштувати та скомпілювати c-lightning безпосередньо з вихідного коду. Це необов’язковий та просунутий крок, який навчить вас користуватися інструментами збірки та дозволить вам модифікувати вихідний код c-lighting. Завдяки цим знанням ви зможете написати якийсь свій код, виправити деякі помилки або створити плагін для c-lightning. Якщо ви не плануєте занурюватися у вихідний код або програмувати ноду Lightning, ви можете повністю пропустити наступну секцію. Щойно створений docker-контейнер буде цілком достатнім для більшості прикладів у книзі.

==== Інсталяція c-lightning з вихідного коду

Розробники c-lightning надали детальні інструкції щодо збірки c-lightning із вихідного коду. Ми будемо слідувати інструкціям звідси:

https://github.com/ElementsProject/lightning/blob/master/doc/INSTALL.md

====  Інсталяція необхідних бібліотек та пакунків

Першим кроком є встановлення необхідних бібліотек. Використаємо менеджер пакунків +apt+ для цього:

----
$ sudo apt-get update

Get:1 http://security.ubuntu.com/ubuntu bionic-security InRelease [88.7 kB]
Hit:2 http://eu-north-1b.clouds.archive.ubuntu.com/ubuntu bionic InRelease
Get:3 http://eu-north-1b.clouds.archive.ubuntu.com/ubuntu bionic-updates InRelease [88.7 kB]

[...]

Fetched 18.3 MB in 8s (2,180 kB/s)
Reading package lists... Done

$ sudo apt-get install -y \
  autoconf automake build-essential git libtool libgmp-dev \
  libsqlite3-dev python python3 python3-mako net-tools zlib1g-dev \
  libsodium-dev gettext

Reading package lists... Done
Building dependency tree
Reading state information... Done
The following additional packages will be installed:
  autotools-dev binutils binutils-common binutils-x86-64-linux-gnu cpp cpp-7 dpkg-dev fakeroot g++ g++-7 gcc gcc-7 gcc-7-base libalgorithm-diff-perl

 [...]

Setting up libsigsegv2:amd64 (2.12-2) ...
Setting up libltdl-dev:amd64 (2.4.6-14) ...
Setting up python2 (2.7.17-2ubuntu4) ...
Setting up libsodium-dev:amd64 (1.0.18-1) ...

[...]
$
----

Через кілька хвилин і багато тексту на екрані всі необхідні пакети та бібліотеки буде встановлено. Багато з цих бібліотек також використовуються іншими пакетами Lightning та потрібні для розробки програмного забезпечення загалом.

==== Копіювання вихідного коду c-lightning

Далі ми скопіюємо останню версію c-lightning із репозиторію. Для цього ми використаємо команду +git clone+, яка клонує копію вихідного коду на вашу локальну машину, що дозволить синхронізувати майбутні зміни без необхідності повторного завантаження цілого репозиторію:

----
$ git clone https://github.com/ElementsProject/lightning.git
Cloning into 'lightning'...
remote: Enumerating objects: 24, done.
remote: Counting objects: 100% (24/24), done.
remote: Compressing objects: 100% (22/22), done.
remote: Total 53192 (delta 5), reused 5 (delta 2), pack-reused 53168
Receiving objects: 100% (53192/53192), 29.59 MiB | 19.30 MiB/s, done.
Resolving deltas: 100% (39834/39834), done.

$ cd lightning

----

Тепер в нас є копія c-lightning у каталозі +lightning+, і ми виконали команду +cd+ (змінити каталог) для переходу в нього.

==== Компіляція вихідного коду c-lightning

Далі ми використовуємо набір _скриптів для збірки_, які зазвичай доступні у багатьох проектах з відкритим кодом. Ці _скрипти для збірки_ використовують команди +configure+ і +make+, які дозволяють нам:

* Вказати параметри збірки та перевірити необхідні залежності (+configure+).
* Зібрати та інсталювати програми та бібліотеки (+make+).

Запуск +configure+ з опцією +help+ виведе на екран список доступних опцій:

----
$ ./configure --help
Usage: ./configure [--reconfigure] [setting=value] [options]

Options include:
  --prefix= (default /usr/local)
    Prefix for make install
  --enable/disable-developer (default disable)
    Developer mode, good for testing
  --enable/disable-experimental-features (default disable)
    Enable experimental features
  --enable/disable-compat (default enable)
    Compatibility mode, good to disable to see if your software breaks
  --enable/disable-valgrind (default (autodetect))
    Run tests with Valgrind
  --enable/disable-static (default disable)
    Static link sqlite3, gmp and zlib libraries
  --enable/disable-address-sanitizer (default disable)
    Compile with address-sanitizer
----

Для цього прикладу нам не потрібно змінювати жодні опції, встановлені за замовчуванням. Отже, ми знову запускаємо +configure+ без жодних опцій:

----
$ ./configure

Compiling ccan/tools/configurator/configurator...done
checking for python3-mako... found
Making autoconf users comfortable... yes
checking for off_t is 32 bits... no
checking for __alignof__ support... yes

[...]

Setting COMPAT... 1
PYTEST not found
Setting STATIC... 0
Setting ASAN... 0
Setting TEST_NETWORK... regtest
$
----

Далі запустимо збірку бібліотек, компонентів та виконуваних файлів проекту c-lightning за допомогою команди +make+. Ця процедура займе кілька хвилин і сильно навантажить центральний процесор та диск вашого комп’ютера. Чекайте шуму від кулерів! Запустіть +make+:

----
$ make

cc -DBINTOPKGLIBEXECDIR="\"../libexec/c-lightning\"" -Wall -Wundef -Wmis...

[...]

cc   -Og  ccan-asort.o ccan-autodata.o ccan-bitmap.o ccan-bitops.o ccan-...

----

Якщо все буде добре, то ви не побачите жодного повідомлення +ERROR+, яке б зупинило виконання вищевказаної команди. Програмний пакет c-lightning скомпільовано із вихідного коду, і тепер ми можемо інсталювати створені на попередньому кроці програми:

----
$ sudo make install

mkdir -p /usr/local/bin
mkdir -p /usr/local/libexec/c-lightning
mkdir -p /usr/local/libexec/c-lightning/plugins
mkdir -p /usr/local/share/man/man1
mkdir -p /usr/local/share/man/man5
mkdir -p /usr/local/share/man/man7
mkdir -p /usr/local/share/man/man8
mkdir -p /usr/local/share/doc/c-lightning
install cli/lightning-cli lightningd/lightningd /usr/local/bin
[...]
----

Щоб перевірити, що програми +lightningd+ та +lightning-cli+ було встановлено правильно, ми запитаємо їх версії:

----
$ lightningd --version
v0.8.1rc2
$ lightning-cli --version
v0.8.1rc2
----

Можливо, ви побачите відмінну версію від наведеної вище, оскільки програмне забезпечення продовжуватиме розвиватися після публікації цієї книги. Однак незалежно від того, яку версію ви бачите, той факт, що команди виконуються та видають інформацію про версію, означає, що вам вдалося зібрати програмне забезпечення c-lightning.

=== Нода Lightning Network Daemon (LND)

Lightning Network Daemon (LND) є повною реалізацією ноди Lightning Network від компанії Lightning Labs. Проект LND пропонує ряд програм, включаючи +lnd+ (сам демон) та +lncli+ (утиліта командного рядка). LND може підключатись до кількох сервісів включно з btcd (повна нода), bitcoind (Bitcoin Core) та neutrino (новий експериментальний легкий клієнт). LND написаний мовою програмування Go. Проект відкритий і спільно розробляється на Github:

https://github.com/LightningNetwork/lnd

У наступних секціях ми створимо docker-контейнер для запуску LND, зберемо LND з вихідного коду та дізнаємося, як налаштувати та запустити LND.

==== LND у вигляді docker-контейнера

Якщо ви слідкувати за попередніми прикладами з цього розділу, то вже добре знайомі з основними командами docker. У цій секції ми повторимо їх для створення контейнера LND. Контейнер знаходиться в +code/docker/lnd+. В терміналі перейдемо в робочий каталог +code/docker+ і запустимо команду +docker build+:

----
$ cd code/docker
$ docker build -t lnbook/lnd lnd
Sending build context to Docker daemon  9.728kB
Step 1/29 : FROM golang:1.13 as lnd-base
 ---> e9bdcb0f0af9
Step 2/29 : ENV GOPATH /go

[...]

Step 29/29 : CMD ["/usr/local/bin/logtail.sh"]
 ---> Using cache
 ---> 397ce833ce14
Successfully built 397ce833ce14
Successfully tagged lnbook/lnd:latest

----

Тепер наш контейнер створено і він готовий до роботи. Як і у випадку з контейнером c-lightning, який ми створили раніше, контейнер LND також залежить від запущеного екземпляра Bitcoin Core. Як і раніше, нам потрібно запустити контейнер bitcoind в іншому терміналі і підключити до нього LND через мережу docker. Ми вже створили docker мережу під назвою +lnbook+ і використаємо її знову.

[TIP]
====
Зазвичай кожен оператор ноди запускає свою власну ноду Lightning та власну ноду Bitcoin на своєму сервері. В нашому випадку один контейнер bitcoind може обслуговувати багато нод Lightning. В нашій симульованій мережі ми можемо запустити кілька нод Lightning, всі вони підключаються до однієї ноди Bitcoin в режимі regtest.
====

==== Запуск контейнерів bitcoind та LND

Як і раніше, ми запускаємо контейнер bitcoind в одному терміналі, а LND в іншому. Якщо у вас вже запущений контейнер bitcoind, вам не потрібно його перезапускати. Просто залиште його запущеним і пропустіть наступний крок. Для запуску bitcoind в мережі +lnbook+ ми використовуємо +docker run+ наступним чином:

----
$ docker run -it --network lnbook --name bitcoind lnbook/bitcoind
----

Наступним кроком запустимо щойно створений контейнер LND. Як і раніше, нам потрібно під'єднати його до мережі +lnbook+ і дати йому ім'я:

----
$ docker run -it --network lnbook --name lnd lnbook/lnd
Waiting for bitcoind to start...
Waiting for bitcoind to mine blocks...
Starting lnd...
Startup complete
Funding lnd wallet
{"result":"795a8f4fce17bbab35a779e92596ba0a4a1a99aec493fa468a349c73cb055e99","error":null,"id":"lnd-run-container"}

[...]

2020-06-23 13:42:51.841 [INF] LTND: Active chain: Bitcoin (network=regtest)

----

Контейнер LND запускається і підключається до контейнера bitcoind через docker-мережу. Спочатку наша нода LND чекатиме на запуск bitcoind, а потім чекатиме поки bitcoind змайнить трохи біткоїнів у свій гаманець. Нарешті, в ході запуску контейнера, скрипт надішле bitcoind-ноді RPC-команду створення транзакції, яка переводить на гаманець LND 10 тестових BTC.

Як було показано раніше, ми можемо давати команди нашому контейнеру в іншому терміналі для отримання інформації, отримання переліку відкритих каналів тощо. Команда, що дозволяє нам давати інструкції демону +lnd+, називається +lncli+. Щоб отримати інформацію про ноду, виконайте наступну команду +docker exec+ в іншому вікні терміналу:

----
$ docker exec lnd lncli -n regtest getinfo
{
    "version": "0.10.99-beta commit=clock/v1.0.0-85-gacc698a6995b35976950282b29c9685c993a0364",
    "commit_hash": "acc698a6995b35976950282b29c9685c993a0364",
    "identity_pubkey": "03e436739ec70f3c3630a62cfe3f4b6fd60ccf1f0b69a0036f73033c1ac309426e",
    "alias": "03e436739ec70f3c3630",
    "color": "#3399ff",
    "num_pending_channels": 0,
    "num_active_channels": 0,
    "num_inactive_channels": 0,
 [...]
}
----

Тепер у нас є ще одна нода Lightning, яка працює в мережі +lnbook+ і спілкується з bitcoind. Якщо у вас запущений контейнер c-lightning, то зараз працює дві ноди. Вони ще не з'єднані між собою, але невдовзі ми їх з'єднаємо.

За бажанням ви можете запустити будь-яку комбінацію нод LND та c-lightning в тій самій мережі Lightning. Наприклад, щоб запустити другий вузол LND, виконайте команду +docker run+ з іншим ім'ям контейнера, наприклад так:

----
$ docker run -it --network lnbook --name lnd2 lnbook/lnd
----

У наведеній вище команді ми запускаємо інший контейнер LND під назвою +lnd2+. Ви можете вказати будь-яке унікальне ім'я. Якщо ви не вкажете ім'я, docker самостійно створить унікальне ім'я із двох випадкових англійських слів, наприклад "naughty_einstein" ("Вередливий Айнштайн"). Це була справжня назва, яку обрав нам docker, коли ми писали цей параграф. Як смішно!

У наступній секції ми розглянемо, як завантажити та скомпілювати LND безпосередньо з вихідного коду. Це необов’язковий та просунутий крок, який навчить вас користуватися інструментами збірки мови Go та дозволить вам модифікувати вихідний код LND. Завдяки цим знанням ви зможете написати якийсь свій код або виправити деякі помилки. Якщо ви не плануєте занурюватися у вихідний код або програмувати ноду Lightning, ви можете повністю пропустити наступну секцію. Щойно створений docker-контейнер буде цілком достатнім для більшості прикладів у книзі.

==== Інсталяція LND з вихідного коду

У цій секції ми зберемо LND з нуля. LND написаний мовою програмування Go. ЯКЩО ви хочете дізнатись більше про Go, шукайте за запитом +golang+ замість +go+, щоб уникнути нерелевантних результатів. Оскільки LND написаний на Go, а не на C чи C++, він використовує інший спосіб збірки, ніж GNU autotools/make, який ми бачили раніше у c-lightning. Але не засмучуйтесь, це досить легко, ми крок за кроком покажемо як встановити та використовувати інструменти golang. Go - це фантастична мова для спільної розробки програмного забезпечення, оскільки вона дозволяє робити дуже сумісний, чіткий і легкий для читання код незалежно від кількості авторів. Go сфокусований і "мінімалістичний" в плані узгодження різних версій мови. Go - компільована мова, тому вона також є досить ефективною. Давайте зануримось глибше.

Прослідуємо по інструкції з інсталяції, наведеній у проектній документації LND:

https://github.com/lightningnetwork/lnd/blob/master/docs/INSTALL.md

Спочатку встановимо пакет +golang+ та пов'язані з ним бібліотеки. Нам потрібна версія Go 1.13 або пізніша. Офіційні пакети мови Go розповсюджуються у вигляді двійкових файлів з https://golang.org/dl. Для зручності вони також розповсюджуються у вигляді пакетів Debian і доступні за допомогою команди +apt+. Ви можете слідувати інструкціям на https://golang.org/dl або використовувати команди +apt+ для системи Debian/Ubuntu Linux, як описано на https://github.com/golang/go/wiki/Ubuntu:

----
$ sudo apt install golang-go
----

Переконайтесь, що правильна версія встановлена та готова до використання:

----
$ go version
go version go1.13.4 linux/amd64
----

Наша версія 1.13.4, тож ми готові... Далі нам потрібно вказати іншим програмам, де їм шукати код Go. Для цього потрібно встановити змінну середовища +GOPATH+. Зазвичай код Go знаходиться в каталозі з іменем +gocode+ безпосередньо в домашньому каталозі користувача. За допомогою наступних двох команд ми встановлюємо значення змінних середовища +GOPATH+ і +PATH+. Зверніть увагу на те, що домашній каталог користувача називається +~+.

----
$ export GOPATH=~/gocode
$ export PATH=$PATH:$GOPATH/bin
----

Щоб не встановлювати ці змінні середовища кожного разу при відкритті шеллу, ви можете додати ці два рядки до кінця вашого конфігураційного файлу +.bashrc+ у домашньому каталозі за допомогою вибраного вами текстового редактора.

==== Копіювання вихідного коду LND

Як і у випадку з багатьма проектами з відкритим кодом, вихідний код LND знаходиться на Github (www.github.com). Команда +go get+ може отримати її безпосередньо за протоколом git:

----
$ go get -d github.com/lightningnetwork/lnd
----

Як тільки +go get+ закінчить свою роботу, у вас з’явиться підкаталог у +GOPATH+, що містить вихідний код LND.

==== Компіляція вихідного коду LND

Для збірки LND використовується команда +make+. Щоб зібрати проект, ми переходимо в каталог з вихідним кодом LND, а потім запускаємо +make+:

----
$ cd $GOPATH/src/github.com/lightningnetwork/lnd
$ make && make install
----

Після кількох хвилин у вас буде встановлено дві нові команди +lnd+ та +lncli+. Спробуйте їх і перевірте їх версію, щоб переконатися, що вони встановлені:

----
$ lnd --version
lnd version 0.10.99-beta commit=clock/v1.0.0-106-gc1ef5bb908606343d2636c8cd345169e064bdc91
$ lncli --version
lncli version 0.10.99-beta commit=clock/v1.0.0-106-gc1ef5bb908606343d2636c8cd345169e064bdc91
----

Можливо, ви побачите відмінну версію від наведеної вище, оскільки програмне забезпечення продовжуватиме розвиватися після публікації цієї книги. Однак незалежно від того, яку версію ви бачите, той факт, що команди виконуються та видають інформацію про версію, означає, що вам вдалося зібрати програмне забезпечення LND.

=== Lightning нода Eclair

Eclair ("блискавка" французькою мовою) - це реалізація Lightning Network мовою Scala, зроблена компанією ACINQ. Eclair також є одним з найпопулярніших та новаторських мобільних Lightning-гаманців, який ми використовували для демонстрації Lightning-платежу в другому розділі. У цьому розділі ми розглядаємо серверну ноду Eclair. Eclair - це проект з відкритим кодом, і його можна знайти на GitHub:

https://github.com/ACINQ/eclair


В наступних секціях ми створимо docker-контейнер для запуску Eclair, як ми робили раніше з c-lightning та LND. Ми також зберемо Eclair безпосередньо з вихідного коду.

==== Eclair у вигляді docker-конейтера

Ви вже майже експерт в основних операціях docker! У цій секції ми повторимо багато раніше використаних команд для створення контейнера Eclair. Контейнер знаходиться в +code/docker/eclair+. Ми починаємо з терміналу, переходимо в робочий каталог +code/docker+ і виконуємо команду +docker build+:

----
$ cd code/docker
$ docker build -t lnbook/eclair eclair
Sending build context to Docker daemon  9.216kB
Step 1/22 : FROM ubuntu:20.04 AS eclair-base
 ---> c3c304cb4f22
Step 2/22 : RUN apt update && apt install -yqq 	curl gosu jq bash-completion
 ---> Using cache
 ---> 3f020e1a2218
Step 3/22 : RUN apt update && apt install -yqq 	openjdk-11-jdk unzip
 ---> Using cache
 ---> b068481603f0

[...]

Step 22/22 : CMD ["/usr/local/bin/logtail.sh"]
 ---> Using cache
 ---> 5307f28ff1a0
Successfully built 5307f28ff1a0
Successfully tagged lnbook/eclair:latest

----

Тепер наш контейнер створено і він готовий до роботи. Перед запуском контейнера Eclair, нам треба запустити контейнер bitcoind в іншому терміналі, оскільки Eclair залежить від bitcoind. Ми вже створили мережу docker під назвою +lnbook+ і будемо використовувати її знову.

Одна важлива відмінність між Eclair та LND або c-lightning полягає в тому, що нода Eclair не містить в собі біткоїн-гаманця, натомість Eclair покладається на біткоїн-гаманець у Bitcoin Core. Нагадаємо, що використовуючи LND ми "профінансували" його біткоїн-гаманець, перевівши біткоїни з гаманця Bitcoin Core на гаманець LND. Цей крок зайвий у випадку Eclair. При запуску Eclair гаманець Bitcoin Core використовується безпосередньо як джерело коштів для відкриття каналів. В результаті, на відміну від контейнерів LND або c-lightning, контейнер Eclair не містить скрипта для переводу біткоїнів у свій гаманець при запуску.

==== Запуск контейнерів bitcoind і Eclair

Як і раніше, ми запускаємо контейнер bitcoind в одному терміналі і контейнер Eclair - в іншому. Якщо контейнер bitcoind вже запущено, то перезапускати його не потрібно. Просто залиште його запущеним і переходьте до наступного кроку. Щоб запустити +bitcoind+ в мережі +lnbook+, використаємо команду +docker run+ наступним чином:

----
$ docker run -it --network lnbook --name bitcoind lnbook/bitcoind
----

Далі запустимо щойно створений контейнер Eclair. Нам потрібно під'єднати його до мережі +lnbook+ і дати йому ім'я, як ми це робили з іншими контейнерами:

----
$ docker run -it --network lnbook --name eclair lnbook/eclair
Waiting for bitcoind to start...
Waiting for bitcoind to mine blocks...
Starting eclair...
Eclair node started
/usr/local/bin/logtail.sh
INFO  fr.acinq.eclair.Plugin$ - loading 0 plugins
INFO  a.e.slf4j.Slf4jLogger - Slf4jLogger started
INFO  fr.acinq.eclair.Setup - hello!
INFO  fr.acinq.eclair.Setup - version=0.4 commit=69c538e
[...]

----

Контейнер Eclair запускається і підключається до контейнера bitcoind через docker-мережу. Спочатку наша нода Eclair чекатиме на запуск bitcoind, а потім чекатиме поки bitcoind змайнить трохи біткоїнів у свій гаманець.

Як було показано раніше, ми можемо давати команди нашому контейнеру в іншому терміналі для отримання інформації, відкриття каналів тощо. Команда, що дозволяє нам давати інструкції демону +eclair+, називається +eclair-cli+. Команда +eclair-cli+ потребує пароль, який ми попередньо встановили на цьому контейнері у значення "eclair". Ми передаємо пароль +eclair+ в команду +eclair-cli+ через флаг +p+. За допомогою команди +docker exec+ в іншому терміналі ми отримуємо інформацію про ноду Eclair:

----
$ docker exec eclair eclair-cli -p eclair getinfo
{
  "version": "0.4-69c538e",
  "nodeId": "03ca28ed39b412626dd5efc514add8916282a1360556f8101ed3f06eea43d6561a",
  "alias": "eclair",
  "color": "#49daaa",
  "features": "0a8a",
  "chainHash": "06226e46111a0b59caaf126043eb5bbf28c34f3a5e332a1fc7b2b73cf188910f",
  "blockHeight": 123,
  "publicAddresses": []
}

----

Тепер у нас є ще одна Lightning-нода, яка працює в мережі +lnbook+ і спілкується з bitcoind. Ви можете запускати будь-яку кількість та будь-яку комбінацію нод Lightning в одній мережі Lightning. Будь-яка кількість нод Eclair, LND та c-lightning може співіснувати. Наприклад, щоб запустити другу ноду Eclair, виконайте команду +docker run+ з іншим ім'ям контейнера:

----
$ docker run -it --network lnbook --name eclair2 lnbook/eclair
----

Вищенаведеною командою ми запускаємо ще один контейнер Eclair під назвою +eclair2+.

У наступній секції ми також розглянемо, як завантажити, налаштувати та скомпілювати Eclair безпосередньо з вихідного коду. Це необов’язковий та просунутий крок, який навчить вас користуватися інструментами збірки мов Scala та Java та дозволить вам модифікувати вихідний код Eclair. Завдяки цим знанням ви зможете написати якийсь свій код чи виправити деякі помилки. Якщо ви не плануєте занурюватися у вихідний код або програмувати ноду Lightning, ви можете повністю пропустити наступну секцію. Щойно створений docker-контейнер буде цілком достатнім для більшості прикладів у книзі.

==== Інсталяція Eclair з вихідного коду

У цьому розділі ми зберемо Eclair з нуля. Eclair написаний мовою програмування Scala, яка компілюється за допомогою компілятора Java. Для запуску Eclair нам спочатку потрібно встановити Java та її інструменти збірки. Ми будемо слідувати інструкціям, наведеним у документі BUILD.md проекту Eclair:

https://github.com/ACINQ/eclair/blob/master/BUILD.md

Потрібний нам компілятор Java є частиною OpenJDK 11. Нам також знадобиться фреймворк для збірки під назвою Maven версії 3.6.0 або новішої.

У Debian/Ubuntu Linux ми можемо використати команду +apt+ для встановлення OpenJDK11 і Maven, як показано нижче:

----
$ sudo apt install -y openjdk-11-jdk maven
----

Переконайтесь, що правильна версія встановлена, запустивши:

----
$ javac -version
javac 11.0.7
$ mvn -v
Apache Maven 3.6.1
Maven home: /usr/share/maven
Java version: 11.0.7, vendor: Ubuntu, runtime: /usr/lib/jvm/java-11-openjdk-amd64

----

Ми маємо OpenJDK 11.0.7 та Maven 3.6.1, отже ми готові.

==== Копіювання вихідного коду Eclair

Вихідний код Eclair лежить на Github. Командою +git clone+ створимо його локальну копію. Перейдемо до нашого домашнього каталогу та запустимо її звідти:

----
$ cd ~
$ git clone https://github.com/ACINQ/eclair.git

----

Як тільки +git clone+ завершить свою роботу, у вас буде підкаталог +eclair+ з вихідним кодом серверу Eclair.

==== Компіляція вихідного коду Eclair

Eclair використовує систему збірки +Maven+. Для збірки проекту ми переходимо в каталог з вихідним кодом Eclair, а потім виконуємо команду +mvn package+:

----
$ cd eclair
$ mvn package
[INFO] Scanning for projects...
[INFO] ------------------------------------------------------------------------
[INFO] Reactor Build Order:
[INFO]
[INFO] eclair_2.13                                                        [pom]
[INFO] eclair-core_2.13                                                   [jar]
[INFO] eclair-node                                                        [jar]
[INFO] eclair-node-gui                                                    [jar]
[INFO]
[INFO] --------------------< fr.acinq.eclair:eclair_2.13 >---------------------
[INFO] Building eclair_2.13 0.4.1-SNAPSHOT                                [1/4]
[INFO] --------------------------------[ pom ]---------------------------------

[...]

[INFO] eclair_2.13 ........................................ SUCCESS [  3.032 s]
[INFO] eclair-core_2.13 ................................... SUCCESS [  7.935 s]
[INFO] eclair-node ........................................ SUCCESS [ 35.127 s]
[INFO] eclair-node-gui .................................... SUCCESS [ 20.535 s]
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time:  01:06 min
[INFO] Finished at: 2020-06-26T09:43:21-04:00
[INFO] ------------------------------------------------------------------------

----

Через кілька хвилин збірка пакета Eclair завершиться. Ви знайдете ноду Eclair у папці +eclair-node/target+ у вигляді zip-файлу. Розпакуйте та запустіть його, дотримуючись інструкції:

https://github.com/ACINQ/eclair#installing-eclair

Вітаємо! Ви зібрали Eclair з вихідного коду і тепер готові писати код, тестувати, виправляти помилки та робити свій внесок в цей проект!

=== Building a complete network of diverse Lightning Nodes

Our final example, presented in this section, will bring together all the various containers we have built to form a Lightning network made of diverse (LND, c-lightning, Eclair) node implementations. We will compose the network by connecting the nodes together and opening channels from one node to another. As the final step we route a payment across these channels.

In this example, we will replicate the Lighting network example from <<routing_on_a_network_of_payment_channels>>. Specifically, we will create four Lightning nodes named Alice, Bob, Wei, and Gloria. We will connect Alice to Bob, Bob to Wei, and Wei to Gloria. Finally, we will have Gloria create an invoice and have Alice pay that invoice. Since Alice and Gloria are not directly connected, the payment will be routed as an HTLC across all the payment channels.

==== Using docker-compose to orchestrate docker containers

To make this example work, we will be using a _container orchestration_ tool that is available as a command called +docker-compose+. This command allows us to specify an application composed of several containers and run the application by launching all the cooperating containers together.

First, let's install +docker-compose+. The instructions depend on your operating system and can be found here:

https://docs.docker.com/compose/install/

Once you have completed installation, you can verify your installation by running docker-compose like this:

----
$ docker-compose version
docker-compose version 1.21.0, build unknown
[...]

----

The most common +docker-compose+ commands we will use are +up+ and +down+, e.g. +docker-compose up+.

==== Docker-compose configuration

The configuration file for +docker-compose+ is found in the +code/docker+ directory and is named +docker-compose.yml+. It contains a specification for a network and each of the four containers. The top looks like this:

----
version: "3.3"
networks:
  lnnet:

services:
  bitcoind:
    container_name: bitcoind
    build:
        context: bitcoind
    image: lnbook/bitcoind:latest
    networks:
      - lnnet
    expose:
      - "18443"
      - "12005"
      - "12006"

  Alice:
    container_name: Alice
----

The fragment above defines a network called +lnnet+ and a container called +bitcoind+ which will attach to the +lnnet+ network. The container is the same one we built at the beginning of this chapter. We expose three of the container's ports allowing us to send commands to it and monitor blocks and transactions. Next, the configuration specifies an LND container called "Alice". Further down you will also see specifications for containers called "Bob" (c-lightning), "Wei" (Eclair) and "Gloria" (LND again).

Since all these diverse implementations follow the Basis of Lightning Technologies (BOLT) specification and have been extensively tested for interoperability, they have no difficulty working together to build a Lightning network.

==== Starting the example Lightning network

Before we get started, we should make sure we're not already running any of the containers. If a new container shares the same name as one that is already running, then it will fail to launch. Use +docker ps+, +docker stop+, and +docker rm+ as necessary to stop and remove any currently running containers!

[TIP]
====
Because we use the same names for these orchestrated docker containers, we might need to "clean up" to avoid any name conflicts.
====

To start the example, we switch to the directory that contains the +docker-compose.yml+ configuration file and we issue the command +docker-compose up+:

----
$ cd code/docker
$ docker-compose up
Creating network "docker_lnnet" with the default driver
Creating Wei      ... done
Creating Bob      ... done
Creating Gloria   ... done
Creating Alice    ... done
Creating bitcoind ... done
Attaching to Wei, Bob, Gloria, Alice, bitcoind
Bob         | Waiting for bitcoind to start...
Wei         | Waiting for bitcoind to start...
Alice       | Waiting for bitcoind to start...
Gloria      | Waiting for bitcoind to start...
bitcoind    | Starting bitcoind...

[...]
----

Following the start up, you will see a whole stream of log files as each of the nodes starts up and reports its progress. It may look quite jumbled on your screen, but each output line is prefixed by the container name as seen above. If you wanted to watch the logs from only one container, you can do so in another terminal window by using the +docker-compose logs+ command with the +f+ (_follow_) flag and the specific container name:

----
$ docker-compose logs -f Alice
----

==== Opening channels and routing a payment

Our Lightning network should now be running. As we saw in the previous sections of this chapter, we can issue commands to a running docker container with the +docker exec+ command. Regardless of whether we started the container with +docker run+ or started a bunch of them with +docker-compose up+, we can still access containers individually using the docker commands.

To make things easier, we have a little helper script that sets up the network, issues the invoice and makes the payment. The script is called +setup-channels.sh+ and is a Bash shell script. Keep in mind that this script is not very sophisticated! It "blindly" throws commands at the various nodes and doesn't do any error checking. If the network is running correctly and the nodes are funded, then it all works nicely. However, you have to wait a bit for everything to boot up and for the network to mine a few blocks and settle down. This usually takes 1 to 3 minutes. Once you see the block height at 102 or above on each of the nodes, then you are ready. If the script fails, you can stop everything (+docker-compose down+) and try again from the beginning. Or you can manually issue the commands found in the Bash script one by one and look at the results.

[TIP]
====
Before running the +setup-channels.sh+ script note the following: Wait a minute or two after starting the network with +docker-compose+ to assure that all the services are running and all the wallets are funded. To keep things simple, the script doesn't check whether the containers are "ready". Be patient!
====

Let's run the script to see its effect and then we will look at how it works internally. We use +bash+ to run it as a command:

----
$ cd code/docker
$ bash setup-channels.sh
Getting node IDs
Alice: 02c93da7a0a341d28e6d7742721a7d182f878e0c524e3666d80a58e1406d6d9391
Bob: 0343b8f8d27a02d6fe688e3596b2d0834c576672e8750106540617b6d5755c812b
Wei: 03e17cbc7b46d553bade8687310ee0726e40dfa2c629b8b85ca5d888257757edc1
Gloria: 038c9dd0f0153cba3089616836936b2dad9ea7f97ef839f5fbca3a808d232db77b

Setting up channels...
Alice to Bob

Bob to Wei

Wei to Gloria

Get 10k sats invoice from Gloria

Gloria invoice lnbcrt100u1p00w5sypp5fw2gk98v6s4s2ldfwxa6jay0yl3f90j82kv6xx97jfwpa3s964vqdqqcqzpgsp5jpasdchlcx85hzfp9v0zc7zqs9sa3vyasj3nm0t4rsufrl7xge6s9qy9qsqpdd5d640agrhqe907ueq8n8f5h2p42vpheuzen58g5fwz94jvvnrwsgzd89v70utn4d7k6uh2kvp866zjgl6g85cxj6wtvdn89hllvgpflrnex

Wait for channel establishment - 60 seconds for 6 blocks

----

As you can see from the output, the script first gets the node IDs (public keys) for each of the four nodes. Then, it connects the nodes and sets up a 1,000,000 satoshi channel from each node to the next in the network.

Looking inside the script, we see the part that gets all the node IDs and stores them in temporary variables so that they can be used in subsequent command. It looks like this:

----
alice_address=$(docker-compose exec -T Alice bash -c "lncli -n regtest getinfo | jq .identity_pubkey")
bob_address=$(docker-compose exec -T Bob bash -c "lightning-cli getinfo | jq .id")
wei_address=$(docker-compose exec -T Wei bash -c "eclair-cli -s -j -p eclair getinfo| jq .nodeId")
gloria_address=$(docker-compose exec -T Gloria bash -c "lncli -n regtest getinfo | jq .identity_pubkey")
----

If you have followed the first part of the chapter you will recognise these commands and be able to "decipher" their meaning. It looks quite complex, but we will walk through it step-by-step and you'll quickly get the hang of it.

The first command sets up a variable called +alice_address+ that is the output of a +docker-compose exec+ command. The +T+ flag tells docker-compose to not open an interactive terminal. An interactive terminal may mess up the output with things like color-coding of results. The +exec+ command is directed to the +Alice+ container and runs the +lncli+ utility since +Alice+ is an LND node. The +lncli+ command must be told that it is operating on the +regtest+ network and will then issue the +getinfo+ command to LND. The output from +getinfo+ is a JSON-encoded object, which we can parse by piping the output to the +jq+ command. The +jq+ command selects the +identity_pubkey+ field from the JSON object. The contents of the +identity_pubkey+ field are then output and stored in +alice_address+.

The following three lines do the same for each of the other nodes. Because they are different node implementations (c-lightning, Eclair), their command-line interface is slightly different, but the general principle is the same: Use the command utility to ask the node for its public key (node ID) information and parse it with +jq+, storing it in a variable for further use later.

Next, we tell each node to establish a network connection to the next node and open a channel:

----
docker-compose exec -T Alice lncli -n regtest connect ${bob_address//\"}@Bob
docker-compose exec -T Alice lncli -n regtest openchannel ${bob_address//\"} 1000000
----

Both of the commands are directed to the +Alice+ container since the channel will be opened _from_ +Alice+ _to_ +Bob+, and +Alice+ will initiate the connection.

As you can see, in the first command we tell +Alice+ to connect to the node +Bob+. Its node ID is stored in +${bob_address}+ and its IP address can be resolved from the name +Bob+, hence +@Bob+ is used as the network identifier/address. We do not need to add the port number (9375) because we are using the default Lightning ports.

Now that +Alice+ is connected, we open a 1,000,000 satoshi channel to +Bob+ with the +openchannel+ command. Again, we refer to +Bob+'s node by the node ID, i.e. the public key.

We do the same with the other nodes, setting up connections and channels. Each node type has a slightly different syntax for these commands, but the overall principle is the same:

To Bob's node (c-lightning) we send these commands:
----
docker-compose exec -T Bob lightning-cli connect ${wei_address//\"}@Wei 
docker-compose exec -T Bob lightning-cli fundchannel ${wei_address//\"} 1000000
----

To Wei's node (Eclair) we send:
----
docker-compose exec -T Wei eclair-cli -p eclair connect --uri=${gloria_address//\"}@Gloria
docker-compose exec -T Wei eclair-cli -p eclair open --nodeId=${gloria_address//\"} --fundingSatoshis=1000000
----

At this point we create a new invoice for 10,000 satoshis on Gloria's node:

----
gloria_invoice=$(docker-compose exec -T Gloria lncli -n regtest addinvoice 10000 | jq .payment_request)
----

The +addinvoice+ command creates an invoice for the specified amount in satoshis and produces a JSON object with the invoice details. From that JSON object we only need the actual bech32-encoded payment request, which we extract with +jq+.

Next, we have to wait. We just created a bunch of channels. Hence, our nodes broadcast several funding transactions. The channels can't be used until the funding transactions are mined and collect 6 confirmations. Since our Bitcoin +regtest+ blockchain is set to mine blocks every ten seconds, we have to wait 60 seconds for all the channels to be ready to use.

The final command is the actual invoice payment. We connect to Alice's node and present Gloria's invoice for payment.

----
docker-compose exec -T Alice lncli -n regtest payinvoice --json --inflight_updates -f ${gloria_invoice//\"}
----

We ask Alice's node to pay the invoice, but also ask for +inflight_updates+ in +json+ format. That will give us detailed output about the invoice, the route, the HTLCs, and the final payment result. We can study this additional output and learn from it!

Since Alice's node doesn't have a direct channel to Gloria, her node has to find a route. There is only one viable route here (Alice->Bob->Wei->Gloria), which Alice will be able to discover now that all the channels are active and have been advertised to all the nodes by the Lightning gossip protocol. Alice's node will construct the route and create an onion packet to establish HTLCs across the channels. All of this happens in a fraction of a second and Alice's node will report the result of the payment attempt. If all goes well, you will see the last line of the JSON output showing:

----
"failure_reason": "FAILURE_REASON_NONE"
----

This is arguably a weird message, but the fact that there was no failure reason, in a round-about way, implies that the operation was a success!

Scrolling above that unusual message you will see all the details of the payment. There is a lot to review, but as you gain understanding of the underlying technology, more and more of that information will become clear. You are invited to revisit this example later.

Of course, you can do a lot more with this test network than a 3-channel, 4-node payment. Here are some ideas for your experiments:

* Create a more complex network by launching many more nodes of different types. Edit the +docker-compose.yml+ file and copy sections, renaming containers as needed.

* Connect the nodes in more complex topologies: circular routes, hub-and-spoke, or full mesh.

* Run lots of payments to exhaust channel capacity. Then run payments in the opposite direction to rebalance the channels. See how the routing algorithm adapts.

* Change the channel fees to see how the routing algorithm negotiates multiple routes and what optimizations it applies. Is a cheap, long route better than an expensive, short route?

* Run a circular payment from a node back to itself in order to rebalance its own channels. See how that affects all the other channels and nodes.

* Generate hundreds or thousands of small invoices in a loop and then pay them as fast as possible in another loop. Measure how many transactions per second you can squeeze out of this test network.

=== Conclusion

In this chapter we looked at various projects that implement the BOLT specifications. We built containers to run a sample Lightning network and learned how to build each project from source code. You are now ready to explore further and dig deeper. 
