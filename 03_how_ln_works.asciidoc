[role="pagenumrestart"]
[[ch03_How_Lightning_Works]]
== Як Працює Lightning Network

Ми прослідкували за тим, як Аліса створила Lightning-гаманець і придбала каву у Боба, а тепер заглянемо під капот і роздивимось ближче різні компоненти Lightning Network, які приймали участь у цьому процесі.
Мета цього розділу - допомогти усвідомити найважливіші концепції та будівельні блоки Lightning Network. Тому в цьому розділі подається високорівневе уявлення без вникнення у всі технічні подробиці.

Якщо у вас є досвід в галузі інформатики, криптографії, Біткоїна та розробки протоколів, то цієї глави має бути достатньо для того, щоб ви змогли самостійно з'єднати всі деталі між собою.
Якщо ви менш досвідчені, то цей розділ дасть вам достатньо хороше загальне уявлення для більш легкого розуміння офіційних специфікацій протоколу, що відомі як BOLT (Basis of Lightning Technology, Основи Lightning Network).
Якщо ви новачок, ця глава допоможе вам краще зрозуміти технічні розділи книги.

Почнемо з визначення того, що таке Lightning Network (LN), і розберемо його у подальшій частині цього розділу.

**Lightning Network (LN) - це однорангова (peer-to-peer) мережа _платіжних каналів_, реалізована у вигляді смарт-контрактів на _блокчейні Біткоїн_, а також комунікаційний протокол, що визначає, як учасники створюють та виконують ці смарт-контракти**

=== Основи платіжних каналів

Ми побачимо, що платіжний канал - це просто 2-із-2 мультисиг адреса, один ключ якої контролюєти ви, а інший ключ - ваш партнер по каналу.
Ви домовляєтеся з вашим партнером по каналу про послідовність транзакцій, які витрачають кошти з цієї адреси. Замість того, аби публікувати в мережу та записувати ці транзакції на блокчейні, ви обидва утримуєте їх у себе.
Остання транзакція в цій послідовності транзакцій визначає, як саме розподілено кошти в каналі між вами та вашим партнером по каналу.
Таким чином, додавання до цієї послідовності транзакцій нової транзакції рівнозначно переказу частини балансу від одного партнера до іншого без інформування мережі Біткоїн про цю подію. Узгоджучи кожну нову транзакцію і змінюючи розподіл коштів у каналі, ви одночасно з цим відкликаєте попередню транзакцію, щоб жодна із сторін не могла повернутися до попереднього стану.
Кожна транзакція з цієї послідовності використовує мову Script Біткоїна, таким чином узгодження коштів між вами та вашим партнером по каналу регулюється смарт-контрактами Біткоїна.
Смарт-контракт передбачає покарання нечесного учасника каналу, який намагається опублікувати скасований раніше стан каналу.

[NOTE]
====
Якщо у вас є неопублікована транзакція, що витрачає кошти з 2-із-2 мультисиг адреси і виплачує частину залишку вам, то наявність підпису іншої сторони гарантує вам можливість самостійно опублікувати цю транзакцію в будь-який момент, лише додавши власний підпис.

Здатність володіння частково підписаною транзакцією і можливість публікації її та заволодіння балансом у будь-який час - є основою Lightning Network.
====

=== Маршрутизація платежів через канали

Якщо кілька учасників мають канали від одного до іншого, платіж також може бути "перенаправлений" з одного платіжного каналу в інший за допомогою встановлення _шляху_, з'єднуючого послідовність платіжних каналів.

Наприклад, якщо Аліса має канал з Бобом, і Боб має канал з Чарлі, то Аліса може надіслати гроші Чарлі. 

Архітектура Lightning Network дозволяє запрограмувати керуючі каналом смарт-контракти у такий спосіб, що Боб не матиме можливості вкрасти кошти, що проходять через його канал.

Смарт-контракт захищає партнерів по каналу так, що їм не потрібно мати взаємну довіру. Так само вся мережа захищає її учасників, щоб ті могли пересилати платежі без довіри до жодного з учасників мережі.

Оскільки канали побудовані на мультисиг адресах, а транзакції оновлення балансу є попередньо підписаними Біткоїн-транзакціями, то вся довіра, необхідна для роботи Lightning Network, походить від довіри до децентралізованої мережі Біткоїн!

Вищезазначені інновації, безумовно, є головним проривом, який дозволив створення Lightning Network.
Однак Lightning Network - це набагато більше, ніж просто криптографічні протоколи поверх мови Script Біткоїна.
Це всеосяжний комунікаційний протокол, який дозволяє рівноправним учасникам мережі обмінюватися Lightning-повідомленнями для пересилання біткоїнів.

Lightning Network також використовує gossip-протокол (протокол "пліток") для розповсюдження серед всіх учасників мережі публічної інформації про канали (про топологію мережі).

Наприклад, щоб Аліса мала змогу побудувати маршрут до Чарлі, їй треба знати про існування каналу між Бобом і Чарлі, тобто їй потрібна інформація про топологію мережі.

І останнє, але не менш важливе: Lightning Network - це не що інше, як додаток поверх Біткоїна, що використовує Біткоїн-транзакції та мову Script. Не існує "Lightning монети" або "Lightning блокчейна".

Поза технічними примітивами, протокол Lightning Network - це креативний спосіб отримати більше переваг від використання Біткоїну за рахунок проведення довільної кількості миттєвих платежів без необхідності довіряти комусь іншому, крім мережі Біткоїн.

=== Платіжні канали

Як ми бачили в попередньому розділі, Аліса використала свій гаманець для створення платіжного каналу між нею та іншим учасником Lightning Network.
З точки зору інформатики платіжний канал - це криптографічний комунікаційний протокол між вами та вашим партнером по каналу.
Це дозволяє партнерам по каналу надсилати кошти туди-сюди з довільною частотою.

Канал обмежений лише двома речами:
по-перше, час який займає передача через Інтернет кількох байтів даних, необхідних для переміщення коштів з одного кінця каналу на інший.
По-друге, місткість каналу, тобто сума біткоїнів, яка вноситься в канал при його відкритті.

Платіжні канали мають кілька дуже цікавих і корисних властивостей:

* Оскільки час оновлення стану каналу в першу чергу пов’язаний зі швидкістю передачі даних через Інтернет, здійснення платежу через платіжний канал відбувається майже миттєво.

* Якщо канал відкритий, здійснення платежу не вимагає підтвердження блоків Біткоїн. Насправді - доки ви та ваш партнер по каналу дотримуєтесь протоколу - він не вимагає жодної взаємодії з мережею Біткойн або із кимось іншим, крім вашого партнера по каналу.

* Криптографічний протокол побудований таким чином, що не потрібна жодна довіра між партнерами по каналу. Якщо ваш партнер перестає відповідати або намагається вас обдурити, ви можете попросити систему Біткоїн виступити в ролі "суду" за смарт-контрактом, який ви та ваш партнер заключили раніше.

* Платежі, зроблені в платіжному каналі, відомі лише вам і вашому партнеру. У цьому сенсі ви отримуєте більшу конфіденційність порівняно з Біткоїн-транзакціями, де кожна транзакція є публічною. На блокчейні публікується лише остаточний баланс, який є сукупністю всіх платежів у цьому каналі.


Біткоїну було близько 5 років, коли талановиті розробники вперше з'ясували, яким чином можна побудувати платіжні канали. На сьогоднішній день відомо щонайменше три різні методи.
В цьому розділі ми зосередимось на методі побудови каналу, вперше описаному Джозефом Пуном та Тадеушом Дрією у вайтпейпері "Lightning Network" 2015 року. Вони відомі як канали _Пуна-Дрії (Poon-Dryja)_ і на даний момент використовуються в Lightning Network.
Іншими двома методами є канали _Дуплексні Мікроплатежі_ (_Duplex Micropayment_), запропоновані Крістіаном Декером приблизно в той самий час, що й канали "Пуна-Дрії", та канали _eltoo_, запропоновані в 2018 році Крістіаном Декером, Расті Расселом та (співавтором цієї книги) Олаолувою Осунтокуном.

Канали Eltoo мають деякі цікаві властивості та спрощують реалізацію платіжних каналів. Однак, канали eltoo вимагають зміни мови Script Біткоїна, і тому наразі їх неможливо реалізувати в мережі Біткоїн.

==== Мультисиг адреси

Payment channels are built on top of 2-of-2 multisignature addresses, timelocks and Segregated Witness transaction outputs. We will not revise these relatively advanced concepts of the Bitcoin system. Instead, in this section we will provide a high-level overview of multisignature scripts and how they allow us to construct payment channels.
If you have already studied Bitcoin and are familiar with multisignature addresses, feel free to skip this section.

[TIP]
====
A deep dive into the topic discussed here is presented in chapter 7 of Mastering Bitcoin which can be found at: https://github.com/bitcoinbook/bitcoinbook/blob/develop/ch07.asciidoc.
Also, in case you are not familiar with P2PKH addresses and the basic format and scripting language of Bitcoin we encourage you to study chapter 6 of Mastering Bitcoin which can be found at: https://github.com/bitcoinbook/bitcoinbook/blob/develop/ch06.asciidoc.
There is also a video on Rene's YouTube channel which dissects the bits and bytes of a transaction spending from a P2PKH output at: https://youtu.be/1n4g3eYX1UI
====

The Bitcoin scripting language provides a multisignature building block (primitive), that can be used to build escrow services and complex ownership configurations between several stakeholders. An arrangement that requires multiple signatures to spend Bitcoin is called a _multisignature scheme_, further specified as an _K-of-N_ scheme, where:


* N is the total number of signers identified in the multisignature scheme, and
* K is the _quorum_ or _threshold_ - the minimum number of signatures to authorize spending.

The script for an K-of-N multisignature is:

----
K <PubKey1> <PubKey2> ... PubKeyN N CHECKMULTISIG
----

where N is the total number of listed public keys (Public Key 1 through Public Key N) and K is the threshold of required signatures to spend the output.

The Lightning Network uses a 2-of-2 multisignature scheme to build a payment channel. For example, a payment channel between Alice and Bob would be build on a 2-of-2 multisignature like this:

----
2 <PubKey Alice> <PubKey Bob> 2 CHECKMULTISIG
----

The preceding locking script can be satisfied with an unlocking script containing a pair of signatures:

----
0 <Sig Alice> <Sig Bob>
----
The two scripts together would form the combined validation script:

----
0 <Sig Alice> <Sig Bob> 2 <PubKey Alice> <PubKey Bob> 2 CHECKMULTISIG
----

==== Транзакція Фінансування (Funding Transaction)

Фундаментом платіжного каналу є мультисиг адреса 2-із-2. Два партнери по каналу фінансують платіжний канал, надсилаючи біткоїни на мультисиг адресу. Ця транзакція називається _транзакцією фінансування (funding transaction)_, вона записується в блокчейн.

Незважаючи на те, що транзакція фінансування видна всім на блокчейні, одразу не очевидно, що вона відповідає саме за платіжний канал Lightning, аж поки він не буде закритий. Крім того, платежі в каналі, розподіл балансу каналу між партнерами не видні нікому, окрім лише самих партнерів по каналу.

Сума на мультисиг адресі, називається _місткість каналу (channel capacity)_ і встановлює максимальну суму, яку можна надіслати через платіжний канал. Однак, оскільки кошти можна надсилати туди-сюди, місткість каналу не є верхньою межею того, скільки суммарно коштів може протікати по каналу. Так відбувається тому, що коли місткість каналу вичерпується платежами в одному напрямку, то його можна використовувати для надсилання платежів у зворотньому напрямку.


[NOTE]
====
Кошти, надіслані в транзакції фінансування на мультисиг адресу іноді називають "заблокованими в Lightning-каналі". Однак на практиці кошти в Lightning-каналі не "блокуються", а навпаки "вивільняються". Кошти в Lightning-каналі більш ліквідні, ніж кошти на блокчейні, оскільки їх можна витратити швидше, дешевше та більш конфіденційно. Відкриття Lightning-каналу вивільняє ваші біткоїни!
====

===== Приклад поганої процедури відкриття каналу

Якщо ви ретельно подумаєте про 2-із-2 мультисиг адреси, то зрозумієте, що розміщення ваших коштів на такій адресі, мабуть, несе певний ризик. Що робити, коли ваш партнер по каналу відмовляється підписати транзакцію, щоб "звільнити" кошти? Вони застрягли назавжди? Давайте розглянемо цей сценарій, і як протокол Lightning Network вирішує цю ситуацію.

Аліса та Боб бажають створити платіжний канал. Кожен з них створює пару ключів (приватний/публічний), після чого вони обмінюються відкритими ключами. Тепер вони можуть створити 2-із-2 мультисиг адресу із двох відкритих ключів, формуючи основу для свого платіжного каналу.

Далі Аліса конструює транзакцію, яка відправляє декілька mBTC на мультисиг адресу, створену з відкритих ключів Аліси та Боба. Якщо б Аліса просто опублікувала цю транзакцію в мережу Біткоїн без жодних додаткових заходів, то їй би довелося довіряти Бобу в тому, що в майбутньому Боб надасть свій підпис, щоб Аліса та Боб могли витратити кошти з цієї мультисиг адреси. В такому випадку у Боба була б можливість шантажувати Алісу, відмовляючи їй в підписі та обмежуючи таким чином Алісі доступ до її коштів.

Для запобігання цьому, Алісі треба створити ще одну транзакцію, яка буде витрачати кошти з мультисиг адреси і повертати їх на її адресу. Далі Аліса просить Боба підписати транзакцію повернення коштів _перед_ тим, як публікувати транзакцію фінансування в мережу Біткоїн. Таким чином, Аліса зможе отримати кошти назад, навіть якщо Боб зникне або перестане співпрацювати.

Транзакція "повернення грошей", яка захищає Алісу, є найпершою в послідовності транзакцій, які називаються _транзакції зобов'язання (commitment transactions)_, які ми детальніше розглянемо далі.

==== Транзакції Зобов'язання (Commitment Transactions)

_Транзакція зобов'язання (commitment transaction)_ - це транзакція, яка сплачує кожному із партнерів по каналу частину балансу та гарантує, що партнерам по каналу не потрібно довіряти один одному. Підписуючи транзакцію зобов'язання, кожен партнер каналу "бере на себе" зобов'язання щодо поточного балансу і надає іншому партнеру можливість отримати свої кошти будь-коли.

Коли у кожного із партнерів по каналу є підписана транзакція зобов’язання, тоді кожен із них може отримати свої кошти навіть без співпраці з іншим партнером по каналу. Це захищає їх обох від того, що інший партнер може зникнути, відмовитись від співпраці або вдатись до шахрайства, порушивши протокол платіжного каналу.

Транзакція зобов’язання, яку Аліса підготувала у попередньому прикладі, була «поверненням» її початкового платежу на мультисиг адресу. Транзакція зобов'язання розподіляє кошти платіжного каналу між партнерами по каналу відповідно до розподілу (балансу), який вони мають. Спочатку весь баланс належить Алісі, тому це просто повернення коштів. Але по мірі руху коштів від Аліси до Боба, вони обмінюватимуться підписами нових транзакцій зобов'язання, що фіксують новий розподіл балансу, причому частина коштів виплачується Алісі, а частина виплачується Бобу.

Припустимо, Аліса відкриває канал з Бобом місткістю 100К сатоші.
Спочатку Аліса володіє 100К сатоші, тобто всіма коштами в каналі. Ось як би працював протокол платіжного каналу:

. Аліса створює нову пару ключів (приватний/публічний) і повідомляє Бобу, що бажає відкрити канал шляхом відправлення йому повідомлення `open_channel` через протокол Lightning Network.
. Боб погоджується прийняти канал від Аліси, створює нову пару ключів (приватний/публічний) і надсилає свій публічний ключ Алісі у повідомленні `accept_channel`.
. Далі Аліса створює транзакцію фінансування зі свого гаманця, якою надсилає 100К сатоші на адресу мультисиг-скрипта +2 <PubKey Alice> <PubKey Bob> 2 CHECKMULTISIG+.
. Аліса ще не публікує в мережу цю транзакцію фінансування, проте надсилає Бобу id транзакції у повідомленні `funding_created`.
. І Аліса, і Боб створюють свої версії першої транзакції зобов'язання. Ця транзакція має витратити вихід транзакції фінансування та відправити усі біткоїни назад на адресу Аліси.
. Алісі та Бобу не потрібно обмінюватися цими транзакціями зобов'язання, оскільки кожен з них може побудувати її самостійно. Їм потрібно лише обмінятися підписами.
. Аліса надає Бобу підпис під транзакцією зобов'язання у повідомленні `funding_created`.
. Боб надає Алісі підпис під транзакцією зобов'язання у повідомленні `funding_signed`.
. Тепер, коли сторони обмінялися підписами, Аліса публікує транзакцію фінансування в мережу Біткоїн.

Слідуючи цього протоколу, Аліса не втрачає права власності на свої 100К сатоші, навіть незважаючи на те, що кошти надсилаються на 2-із-2 мультисиг адресу, від якої лише один ключ знаходиться під контролем Аліси.
Якщо Боб перестане відповідати Алісі, вона зможе опублікувати транзакцію зобов'язання і повернути свої кошти.
Єдиними її витратами будуть комісії за on-chain транзакції.
Поки вона дотримується протоколу, комісії - це її єдиний ризик при відкритті каналу.

Після цього початкового обміну транзакції зобов'язання створюються кожного разу при зміні балансу каналу. Іншими словами, кожного разу, коли між Алісою та Бобом проходить платіж, створюються нові транзакції зобов’язання та відбувається обмін підписами. Кожна нова транзакція зобов’язання кодує останній баланс між Алісою та Бобом.

Якщо Аліса хоче надіслати Бобу 30К сатоші, вони обидва створять нову версію своїх транзакцій зобов'язання, в якій тепер Алісі належить 70К сатоші, а Бобу - 30К сатоші. Кодування нового балансу Аліси та Боба у вигляді нової транзакції зобов'язання є тим засобом, за допомогою якого платіж "відправляється" по каналу.

Тепер, коли ми розуміємо транзакції зобов’язання, розглянемо деякі більш тонкі деталі. Ви могли помітити, що вищенаведений протокол залишає спосіб Алісі або Бобу обдурити свого партнера по каналу.

==== Шахрайство з попереднім станом

Скільки транзакцій зобов’язання є у Аліси після того, як вона заплатить Бобу 30К сатоші? У неї їх дві: в першій транзакції баланс Аліси складає 100К сатоші, в другій - 70К сатоші у Аліси, 30К сатоші у Боба.

У вищенаведеному протоколі каналу ніщо не заважає Алісі опублікувати попередню транзакцію зобов’язань. Аліса-шахрайка може опублікувати транзакцію зобов'язання, яка виплатить їй 100К сатоші.
Оскільки ця транзакція зобов'язання підписана Бобом, то він ніяк не зможе перешкодити Алісі її опублікувати.

Потрібен якийсь механізм, щоб завадити Алісі публікувати стару транзакцію зобов'язання. Спробуємо з’ясувати, як цього досягти і як це дає можливість Lightning Network працювати без необхідності довіри між Алісою та Бобом.

Оскільки Біткоїн стійкий до цензури, ніхто не може перешкодити комусь опублікувати стару транзакцію зобов’язання. Щоб запобігти цьому способу шахрайства, ми маємо будувати такі транзакції зобов’язання, щоб у випадку, коли публікується застаріла транзакція, шахрай міг бути покараний. Роблячи покарання досить великим, ми створюємо сильний стимул проти шахрайства, і це робить систему безпечною.

Покарання працює так, що обманута сторона отримує можливість забрати весь баланс шахрая. Отже, якщо хтось публікує стару транзакцію зобов’язання, в якій йому виплачується більший баланс, інша сторона може покарати шахрая, забравши *обвида* баланси - і свій і шахрая. Шахрай втрачає все.

Знову розглянемо сценарій побудови каналу, додавши механізм покарання за шахрайство:

* Аліса створює канал з Бобом на 100К сатоші.
* Аліса надсилає Бобу 30К сатоші.
* Аліса намагається кинути Боба на 30К сатоші, публікуючи стару транзакцію зобов’язання, забираючи 100К сатоші собі.
* Боб виявляє шахрайство і карає Алісу, забираючи всі 100К сатоші собі.
* В результаті Боб отримує всі 100К сатоші, із яких 70К сатоші він отримує за те, що ловить Алісу на шахрайстві.
* А у Аліси в результаті 0 сатоші.
* Намагаючись обдурити Боба на 30К сатоші, Аліса втратила 70К сатоші, які їй належали.

З таким потужним штрафним механізмом, Аліса не спокушається займатись шахрайством з публікацією старих транзакцій зобов'язання, оскільки так вона ризикує втратити весь свій баланс.

[NOTE]
====
У книзі "Освоєння Bitcoin" Андреас елегантно відмічає:
"Ключовою характеристикою Біткоїна є те, що якщо транзакція є валідною, вона залишається такою і не має обмеженого терміна дії. Єдиний спосіб скасувати транзакцію - це зробити подвійну витрату її входів іншою транзакцією перед тим, як вона буде змайнена".
====

Тепер коли ми зрозуміли, _чому_ потрібен штрафний механізм, і як він запобігає шахрайству, давайте детально розберемось, _як_ він працює.

Зазвичай транзакція зобов’язання має два виходи, які платять кожному із партнерів по каналу. Додамо _блокування за часом (timelock delay)_ та _секрет відкликання (revocation secret)_ до одного із виходів. Блокування за часом не дає власнику виходу витратити його відразу, як тільки транзакція зобов'язання буде включена в блок. Секрет відкликання дозволяє кожному партнеру негайно витратити вихід, оминаючи блокування за часом.

Отже, у нашому прикладі Боб володіє транзакцією зобов’язання, яка негайно платить Алісі, але його власний платіж відкладений в часі та може бути відкликаний. Аліса також має транзакцію зобов'язання, але у неї все навпаки: вона платить Бобу негайно, але її власний платіж відкладений в часі та може бути відкликаний.

Два партнери по каналу зберігають половину секрету відкликання, так що жоден з них не володіє повним секретом. Коли вони діляться своєю половиною секрету з партнером, тоді інший партнер по каналу отримує повний секрет і може використовувати його для виконання умови відкликання. Підписуючи нову транзакцію зобов’язання, вони відкликають попереднє зобов’язання, обмінюючи підпис на секрет відкликання.

Простіше кажучи, Аліса підписує нову транзакцію зобов’язання Боба лише в тому випадку, якщо Боб пропонує свою половину секрету відкликання попереднього зобов’язання. Боб підписує нову угоду про зобов'язання Аліси, лише якщо вона передає йому свою половину секрету відкликання попереднього зобов'язання.

З кожним новим зобов'язанням партнери обмінюються секретом, необхідним для "покарання". Цей секрет дозволяє їм ефективно _відкликати_ попередню транзакцію зобов'язання, роблячи її невигідною її публікацію. По суті, вони руйнують можливість використовувати старі зобов’язання після підписання нових. footnote:[Технічно все ще можливо публікувати старі зобов’язання, але механізм штрафних санкцій робить це економічно невигідним.]

Блокування за часом встановлюється на період до 2016 блоків (приблизно два тижні). Якщо хтось із партнерів по каналу опублікує транзакцію зобов’язаня без співпраці з іншим партнером, то для отримання коштів йому доведеться зачекати, поки буде змайнена задана кількість блоків (наприклад, 2 тижні). Інший партнер по каналу може затребувати власний баланс у будь-який час. Крім того, якщо опубліковане зобов'язання було попередньо відкликане, то партнер по каналу може *також* негайно покарати шахрая і забрати залишок шахрая, минаючи блокування за часом.

Тривалість блокування за часом узгоджується між партнерами по каналу. Зазвичай для каналів з більшою місткістю - воно триває довше, а для менших - коротше.

При кожному оновленні балансу в каналі, необхідно створювати і зберігати нові транзакції зобов’язання та нові секрети відкликання. Допоки канал залишається відкритим, всі _коли-небудь створені_ секрети відкликання, повинні зберігатися, оскільки вони можуть знадобитися в майбутньому. На щастя, секрети досить маленькі, і зберігати їх мають лише 2 партнери по каналу, а не вся мережа. Крім того, завдяки розумному механізму утворення секретів відкликання, ми маємо зберігати лише найсвіжіший секрет, оскільки з нього можна отримати всі попередні секрети (Див. <<revocation_secret_derivation>>.)

Тим не менш, управління та зберігання секретів відкликання є однією з найбільш складних частин Lightning-ноди, що вимагає від операторів нод утримувати резервні копії.

[NOTE]
====
Такі технології, як Сторожові Башти (Watchtowers) і заміна конструкції каналу на протокол "eltoo", можуть в майбутньому згладити ці проблеми та зменшити потребу в секретах відкликання, штрафних операціях та резервних копіях каналів.
====

Якщо Боб перестав відповідати, Аліса може закрити канал в будь-який момент, отримуючи свій належний баланс.
Після публікації на блокчейні *останньої* транзакції зобов’язання Аліса має зачекати, поки пройде певний часовий інтервал, перш ніж вона зможе витратити свої кошти з транзакції зобов’язання. Як ми побачимо далі, існує простіший спосіб закриття каналу без очікування, допоки Аліса та Боб перебувають онлайн та співпрацюють над закриттям каналу з корректним розподілом балансів. Але транзакції зобов’язання, які зберігаються кожним партнером по каналу, діють як гарантія того, що кошти не будуть втрачені при виникненні проблем з їх партнером по каналу.

==== Анонсування каналу

Партнери по каналу можуть домовитись про анонсування свого каналу по всій мережі Lightning, роблячи його _публічним каналом_. Для цього вони використовують протокол пліток Lightning Network, щоб повідомити іншим вузлам про існування, місткість та комісію свого каналу.

Публічне анонсування каналів дозволяє іншим нодам використовувати їх для маршрутизації своїх платежів, що в свою чергу дає можливість партнерам по каналу отримувати комісії за маршрутизацію чужих платежів через свій канал.

Партнери по каналу можуть вирішити не анонсувати свій канал, залишивши його _неанонсованим_.


[NOTE]
====
Ви можете зустріти термін "приватний канал" для неанонсованого каналу. Ми уникаємо використання цього терміна, оскільки він вводить в оману та створює хибне відчуття конфіденційності. Незважаючи на те, що анонсований канал не буде відомим іншим, поки він є відкритим, проте факт його існування та місткість будуть обов'язково виявлені в момент закриття каналу, оскільки ці деталі будуть опубліковані на блокчейні в остаточній розрахунковій транзакції. Інформація про існування неанонсованих каналів також може просочуватися різними іншими способами, тому ми уникаємо назви "приватний канал".
====

Неанонсовані канали використовуються для маршрутизації платежів, але лише тими нодами, які в курсі про їх існування або отримують "маршрутизаційні підказки" про шлях, який проходить через неанонсований канал.

Коли канал та його місткість публічно анонсуються за допомогою протоколу пліток, анонс також може містити таку інформацію про канал (метадані), як комісія за маршрутизацію та тривалість блокування за часом.

Коли нові ноди приєднуються до Lightning Network, вони збирають анонси каналів, які отримують по протоколу пліток від своїх пірів, і будують внутрішню "мапу" Lightning Network. Потім цю мапу можна використовувати для пошуку платіжних шляхів, які з’єднують канали один з одним.

==== Закриття каналу

Найкращий спосіб закрити канал - це... не закривати його! Для відкриття та закриття каналів потрібні on-chain транзакції, за які стягуються комісії. Тому найкраще за все тримати канали відкритими якомога довше. Ви можете продовжувати використовувати свій канал для того, щоб робити свої власні платежі та маршрутизувати чужі платежі, якщо у вас є достатня місткість на кінці каналу. Навіть якщо ви надішлете весь баланс на інший кінець каналу, то ви зможете використовувати канал для отримання платежів від партнера каналу. Ця концепція використання каналу спочатку в одному напрямку, а потім в протилежному називається "ребалансування", і ми більш детально розглянемо її в іншому розділі. Ребалансування каналу може лишати його відкритим майже необмежений час і дозволяє використовувати канал для тисяч платежів.

Однак іноді закриття каналу є бажаним або необхідним. Наприклад:

* Ви хочете зменшити залишок коштів, що зберігається у ваших Lightning-каналах з міркувань безпеки, і хочете передати кошти в "холодне сховище".
* Партнер вашого каналу довго не відповідає, і ви більше не можете користуватися цим каналом.
* Канал використовується не часто, оскільки ваш партнер по каналу не є добре з'єднанною нодою, тому ви хочете використати ці кошти для відкриття іншого каналу з краще з'єднанною нодою.
* Ваш партнер по каналу порушив протокол навмисно або сталася помилка програмного забезпечення, і це змушує вас закрити канал, щоб захистити свої кошти.

Існує 3 способи закриття платіжного каналу:

* Хороший спосіб - Взаємне закриття
* Поганий спосіб - Вимушене закриття
* Жахливий спосіб - Порушення протоколу


Яким чином ви закриєте канал, залежить від обставин. Наприклад, якщо ваш партнер по каналу знаходиться оффлайн, ви не зможете йти "хорошим шляхом", оскільки взаємне закриття неможливе без співпраці з партнером.
Зазвичай, ваше програмне забезпечення Lightning Network автоматично обере найкращий механізм закриття залежно від певних обставин.

Незалежно від того, ви (користувач) даєте команду на закриття каналу, або програмне забезпечення Lightning Network автоматично закриває канал через виявлену аномалію (наприклад, через спробу шахрайства з боку партнера по каналу), як правило, саме програмне забезпечення Lightning Network обирає підходящий спосіб закриття каналу.


===== Хороший спосіб - Взаємне закриття

Хорошим способом закрити канал є взаємне закриття, і цей спосіб завжди є найлішпим, якщо він є можливим. Коли ви вирішите закрити канал, ваша нода Lightning Network повідомить партнера про ваш намір. Тепер і ваша нода, і нода партнера по каналу працюють разом над його закриттям. Жодні нові спроби маршрутизації не будуть прийняті жодним із партнерів по каналу, а всі поточні спроби маршрутизації будуть завершені або видалені після таймауту. Фіналізування спроб маршрутизації вимагає часу, тому взаємне закриття також може зайняти деякий час.

Як тільки не лишається очікуючих розгляду спроб маршрутизації, ноди співпрацюють над підготовкою _закриваючої транзакції (closing transaction)_. Ця транзакція подібна до транзакції зобов'язання, так як розподіляє баланс каналу кожному із партнерів відповідно до останнього зобов'язання. На відміну від останньої транзакції зобов'язання, виходи закриваючої транзакції не блокуються за часом.

Комісія за закриваючу транзакцію сплачується тим, хто відкривав канал,  а не тим, хто ініціював процедуру закриття. Погодившись щодо суми комісії на основі актуальної оцінки on-chain комісій, партнери по каналу підписують закриваючу транзакцію.

Після публікації закриваючої транзакції та підтвердження її мережею Біткоїн, канал закривається, і кожен партнер по каналу отримує свою частку балансу каналу. Взаємне закриття, як правило, це найшвидший спосіб закрити канал.

===== Поганий спосіб - Вимушене закриття

Взаємне закриття не завжди є можливим. Іноді, наприклад, не вдається встановити зв'язок з вашим партнером по каналу, в такому випадку вам доведеться закрити канал в односторонньому порядку, щоб «звільнити» кошти. Закриття каналу в односторонньому порядку називається _вимушеним закриттям (force close)_. Щоб здійснити вимушене закриття, Аліса може просто опублікувати останню транзакцію зобов’язання. Зрештою, для цього і потрібні транзакції зобов’язання - вони дають гарантію того, що Алісі не потрібно довіряти Бобу, щоб отримати баланс каналу, який їй належить.

Як тільки Аліса опублікує свою останню транзакцію зобов’язання в Біткоїн-мережу, і ця транзакція отримає підтвердження, вона створить два виходи - один для Аліси та один для Боба. Як ми вже обговорювали раніше, оскільки ця транзакція зобов'язання проводиться Алісою, це дає невелику "перевагу" Бобу. Вихід Аліси матиме блокування за часом, а вихід Боба може бути витрачений негайно. Це потрібно для захисту Боба, щоб Аліса не могла опублікувати стару транзакцію зобов’язання і вкрасти частину балансу Боба. Блокування за часом дає Бобу змогу "оспорити" таку транзакцію, використовуючи секрет відкликання, і покарати Алісу за шахрайство.

При публікації транзакції зобов'язання під час вимушеного закриття комісія буде дещо більшою, ніж взаємне закриття з кількох причин:

. Коли узгоджується транзакція зобов’язання, партнери по каналу не знають, якими будуть комісії в мережі на той час, коли транзакція буде опублікована. Оскільки комісію неможливо змінити без зміни виходів транзакції зобов'язання (потрібні обидва підписи) і оскільки вимушене закриття відбувається, коли партнер по каналу недоступний для підписання, розробники протоколу вирішили бути дуже щедрими при включенні комісії до транзакції зобов'язання. Вона може бути в 5 разів перевищувати оцінку on-chain комісій на момент узгодження транзакції зобов'язання.
. Транзакція зобов’язання включає додаткові виходи для будь-яких очікуючих спроб маршрутизації (HTLC), що робить транзакцію зобов’язання більшою, ніж транзакція взаємного закриття. Більші транзакції вимагають більших комісій.
. Будь-які очікуючі спроби маршрутизації повинні бути вирішені on-chain, що спричинює додаткові on-chain транзакції.

[NOTE]
====
Блокуючі за хешем і часом транзакції (Hash Time-Locked Contracts, HTLC), будуть детально розглянуті в <<htlcs>>. Поки що вдаватимемо, що це платежі, які маршрутизуються через Ligntning Network, на відміну від платежів, що здійснюються безпосередньо між двома партнерами по каналу. Ці HTLC виглядають як додаткові виходи в транзакціях зобов’язання, чим збільшують розмір транзакції та on-chain комісію.
====

Загалом, ви не повинні проводити "вимушене закриття", звісно якщо це не є необхідним. Ваші кошти будуть заблоковані на довший час, і той хто відкрив канал, повинен буде сплатити вищу комісію. Крім того, можливо, вам доведеться заплатити комісію за те, щоб скасувати або владнати спроби маршрутизації, навіть якщо ви не відкривали канал.

Якщо вам відомий партнер по каналу, ви можете спробувати зв’язатись з цією особою чи компанією та дізнатись, чому їхня Lightning-нода не працює, і попросити перезапустити її, щоб ви змогли виконати взаємне закриття каналу.

Вам варто розглядати вимушене закриття лише як крайній засіб.

===== Жахливий спосіб - Порушення протоколу

Якщо ваш партнер по каналу публікує стару (відкликану) транзакцію зобов’язання - навмисно чи ні - ваша нода повинна мати можливість виявити це порушення протоколу. Для цього ваша нода має бути онлайн та спостерігати за новими блоками та транзакціями на блокчейні Біткоїна. Оскільки вихід вашого партнера по каналу матиме блокування за часом, ваша нода матиме деякий час, щоб діяти, перш ніж ваш партнер по каналу зможе витратити вихід і отримати прибуток від порушення протоколу.

Протягом періоду блокування за часом ваша нода має опублікувати _караючу транзакцію (punishment transaction)_, яка забере ваш власний баланс і використає секрет відкликання, щоб також забрати баланс вашого нечесного партнера по каналу.

В такому випадку закриття каналу буде досить швидким. Щоб опублікувати караючу транзакцію, вам доведеться заплатити комісію, але ваша нода зможе встановити цю комісію відповідно до актуальної оцінки та не переплачувати. Крім того, ви також заберете кошти з балансу свого партнера по каналу, тому комісія навряд чи буде важливим фактором.

Якщо ваша нода не в онлайні, і час дії блокування закінчується, то ваш партнер по каналу зможе забрати баланс із будь-якого старого зобов’язання, можливо навіть весь баланс каналу. Якщо якийсь баланс належить вам, то вам доведеться заплатити on-chain комісію, щоб забрати цей залишок.

Також всі очікуючі спроби маршрутизації повинні бути вирішені так само, як ми бачили у сценарії вимушеного закриття.

"Жахливий спосіб" закриття каналу може бути виконаний швидше, ніж "хороший" і "поганий" способи, оскільки ви можете негайно опублікувати караючу транзакцію і зібрати всі кошти.

Теорія ігор передбачає, що шахрайство не є успішною стратегією, оскільки його легко виявити, і шахрай втратить всі кошти, вкладені в канал.

Отже, ми не рекомендуємо вдаватись до шахрайства. Однак ми рекомендуємо будь-кому, хто зловив шахрая, покарати його, забравши всі його кошти.

Отже, як ви вловлюєте шахрайство або порушення протоколу у своїй повсякденній діяльності?

Для цього ви маєте запустити програмне забезпечення, яке відстежує загальнодоступний Біткоїн-блокчейн щодо он-лайн транзакцій, які стосуються будь-яких транзакцій зобов’язання для кожного з ваших каналів. Це програмне забезпечення:

* Правильно підтримувана Lightning-нода, що працює 24/7 цілодобово та без вихідних.
* _Сторожова Вежа (watchtower)_, що спостерігає за вашими каналами.
* Стороння нода Сторожової Вежі, які ви платите за спостереження своїх каналів.

Ми детальніше розглянемо сторожові вежі в <<watchtowers>>.

Пам’ятайте, що транзакція зобов’язання має період блокування за часом, який вказується у вигляді певної кількості блоків, максимум до 2016.
Якщо ви запустите свою Lightning-ноду один раз до закінчення періоду блокування, вона буде ловити всі спроби шахрайства. Але не бажано вдаватися до такого ризику; простіше тримати ноду в безперервній роботі.

=== Інвойси

Більшість платежів у Lightning Network починаються з інвойса (рахунку-фактури), який генерує отримувач платежу. У нашому попередньому прикладі Боб створює інвойс у відповідь на "запит" платежу від Аліси.

[NOTE]
====
Існує спосіб надіслати "небажаний" платіж без інвойсу в обхід протоколу методом _keysend_. Ми розглянемо це пізніше в <<keysend>>.
====

Інвойс - це проста платіжна інструкція, що містить таку інформацію, як унікальний ідентифікатор платежу, який називається хеш платежу, одержувач, сума та необов’язковий текстовий опис.

Найважливіша частиною інвойсу є хеш платежу, він дозволяє платежу рухатися по кількох каналах в _атомарний_ спосіб. Атомарність означає, що певна дія може бути або повністю успішно виконана, або не виконана взагалі - не буває частково виконаної атомарної дії. У Lightning Network це означає, що платіж або проходить повністю весь шлях, або повністю провалюється. Платіж неможливо виконати частково, щоб якийсь проміжний вузол на шляху міг отримати платіж і залишити його собі.
Не існує такого поняття, як "частковий платіж" або "частково успішний платіж".

Інвойси не передаються через Lightning Network. Натомість вони передаються через будь-який інший механізм зв'язку. Це схоже на те, як Біткоїн-адреси передаються відправникам поза мережею Біткоїн через електронну пошту, у вигляді QR-коду або у текстовому повідомленні. Наприклад, Боб може подати Алісі Lightning-інвойс у вигляді QR-коду або надіслати його електронною поштою або будь-яким іншим способом.

Рахунки, як правило, кодуються у вигляді довгого рядку в кодировці bech32 або у вигляді QR-коду для сканування мобільним Lightning-гаманцем. Інвойс містить запитувану суму біткоїнів та підпис одержувача. Відправник дістає із підпису публічний ключ одержувача (id ноди), щоб відправник знав, куди направити платіж.

Ви помітили, як це контрастує з Біткоїном і які різні терміни використовуються? В Біткоїні одержувач передає відправнику адресу. У Lightning одержувач створює інвойс і відправляє його відправнику. В Біткоїні відправник надсилає кошти на адресу. У Lightning відправник сплачує інвойс, і платіж надходить до одержувача. Біткоїн базується на концепції "адреси", а Lightning - це платіжна мережа і базується на концепції "інвойсу". В Біткоїні ми створюємо "транзакцію", тоді як у Lightning ми надсилаємо "платіж".

==== Хеш та Прообраз Платежу

Найважливішою частиною рахунку-фактури є _хеш платежу_. Конструюючи інвойс, Боб отримує хеш платежу наступним чином:

1. Боб обирає випадкове число +r+. Це випадкове число називається _прообраз_ або _секрет платежу_.
2. Боб обраховує хеш платежу +H+ від +r+, використовуючи хеш-функцію  +SHA256+

latexmath:[H = SHA256(r)].

[NOTE]
====
Термін _preimage_ має математичне походження. Для будь-якої функції _y = f(x)_ всі вхідні значення, при яких функція приймає значення _y_, називаються прообразами _y_. В нашому випадку функцією є алгоритм хешування SHA256, а будь-яке значення _r_, яке має хеш _H_, називається прообразом.
====

Не існує способу знайти обернене значення SHA256 (тобто, вирахувати прообраз за його хешем). Тільки Боб знає значення +r+, тому +r+ - це секрет Боба. Але як тільки Боб оприлюднює +r+, кожен, у кого є хеш +H+, може перевірити, чи є +r+ правильним секретом, обчисливши +SHA256(r)+ і переконавшись, що він дорівнює +H+.

Платіж в Lightning Network є безпечним лише в тому випадку, якщо +r+ вибрано абсолютно випадково. Безпечність платежів покладається на односторонність хеш-функції та неефективність її повного перебору, а отже на те, що ніхто не може знайти +r+, знаючи +H+.

==== Additional Meta Data

Invoices can optionally include other useful meta data such as a short text description. If a user has several invoices to pay, the user can read the description and be reminded what the invoice is about.

The invoice can also include some _routing hints_, which are unannounced channels that have not been publicly announced, but can be used by the sender to construct a route to the recipient. Routing hints can also be used to suggest public channels, for example channels known by the recipient to have enough inbound capacity to route the payment.

In case the sender's Lightning node is unable to send the payment over the Lightning Network, invoices can optionally include an on-chain Bitcoin address as a fallback.

[NOTE]
====
While it is always possible to "fall back" to an on-chain Bitcoin transaction, it is actually better to open a new channel to the recipient instead. If you have to incur on-chain fees to make a payment, you might as well incur those fees to open a channel and make the payment over Lightning. After the payment is made, you are left with an open channel that has liquidity on the recipient's end and can be used to route payments back to your Lightning node in the future. One on-chain transaction gives you a payment and a channel for future use.
====


Lightning invoices contain an expiry date. Since the recipient must keep the preimage +r+ for every invoice issued, it is useful to have invoices expire so that these preimages do not need to be kept forever. Once an invoice expires or is paid, the recipient can discard the preimage.

=== Delivering the payment

We have seen how the recipient creates an invoice that contains a payment hash. This payment hash will be used to move the payment across a series of payment channels, from sender to recipient, even if they do not have a direct payment channel between them.

In the next few sections we will dive into the ideas and methods that are being used to deliver a payment over the Lightning Network and use all the concepts we have presented so far.

First, let's look at the Lightning network's communication protocol.

==== The peer-to-peer gossip protocol

As we mentioned previously, when a payment channel is constructed, the channel partners have the option of making it public, announcing its existence and details to the whole Lightning network.

Channel announcements are communicated over a peer-to-peer _gossip protocol_. A peer-to-peer protocol is a communications protocol where each node connects to a random selection of other nodes in the network, usually over TCP/IP. Each of the nodes that are directly connected (over TCP/IP) to your node are called your _peers_. Your node in turn is one of their peers. Keep in mind, when we say that your node is connected to other peers, we don't mean that you have payment channels, but only via the gossip protocol.

After opening a channel, a node may choose to send out an announcement of the channel via the `channel_announcement` message to its peers.
Every peer validates the information from the `channel_announcement` message and verifies that the funding transaction is confirmed on the Bitcoin blockchain.
After verification the node will forward the gossip message to its own peers, and they will forward to their peers and so on, spreading the announcement across the entire network.
In order to avoid excessive communication the channel announcement is only forwarded by each node if it has not already forwarded that announcement previously.

The gossip protocol is also used to announce information about known nodes, with the `node_announcement` message.
For this message to be forwarded a node has to have at least one public channel announced on the gossip protocol, again to avoid excessive communication traffic.

Payment channels have various meta data that are useful for other participants of the network.
This meta data is mainly used for making routing decisions.
Since nodes might occasionally change the meta data of their channels, this information is shared in a `channel_update` message.
These messages will only be forwarded approximately four times a day (per channel) to prevent excessive communication.
The gossip protocol also has a variety of queries and messages to initially synchronize a node with the view of the network or to update the node's view after being offline for a while.

A major challenge for the participants of the Lightning Network is that the topology information that is being shared by the gossip protocol is only partial.
For example, the capacity of the payment channels is shared on the gossip protocol via the `channel_announcement` message.
However, this information is not as useful as the actual distribution of the capacity into the local balance between the two channel partners.
A node can only forward as much bitcoin as it actually owns (local balance) within that channel.

While Lightning could have been designed to share balance information of channels and a precise topology, this has not been done for several reasons:

. To protect the privacy of the users and not shout out every financial transaction and payment that is being conducted. Channel balance updates would reveal that a payment has moved across the channel. This information could be correlated to reveal all payment sources and destinations.

. To scale the amount of payments that can be conducted with the Lightning Network. Remember that the Lightning Network was created in the first place because notifying every participant about every payment does not scale well. Thus, the Lightning Network cannot be designed in a way that balance updates of channels are  shared among participants.

. The Lightning Network is a dynamic system. It changes constantly and frequently. Nodes are being added, other nodes are being turned off, balances change, etc. Even if everything is always communicated, the information will be valid only for a short amount of time. As a matter of fact, information is often outdated by the time it is received.

We will examine the details of the gossip protocol in a later chapter.

For now, it is only important to know that the gossip protocol exists and that it is used to share topology information of the Lightning Network.
This topology information is crucial for delivering payments through the network of payment channels.


==== Path finding and routing

Payments on the Lightning Network are forwarded along a _path_ made of channels linking one participant to another, from the payment source to the payment destination. The process of finding a path from source to destination is called _path finding_. The process of using that path to make the payment is called _routing_.

[NOTE]
====
A frequent criticism of the Lightning network is that "routing" is not solved, or even is an "unsolvable" problem. In fact, routing is trivial. Path finding, on the other hand, is a difficult problem. The two terms are often confused and need to be clearly defined to identify which problem we are attempting to solve.
====

As we will see next, the Lightning Network currently uses a _source-based_ protocol for path finding and an _onion routed_ protocol for routing payments. Source-based means that the sender of the payment has to find a path through the network to the intended destination. Onion-routed means that the elements of the path are layered (like an onion), with each layer encrypted so that it can only be seen by one node at a time. We will discuss onion routing in the next section.

=== Source-based Path Finding

If we knew the exact channel balances of every channel we could easily compute a payment path using any of the standard path finding algorithms taught in any computer science program. This could even be solved in a way that optimizes the fees paid to nodes for forwarding the payment.

However, the balance information of all channels is not and cannot be known to all participants of the network. We need more innovative path finding strategies.

With only partial information about the network topology, path finding is a real challenge and active research is still being conducted into this part of the Lightning Network. The fact that the path finding problem is not "fully solved" in the Lightning Network is a major point of criticism towards the technology.

[NOTE]
====
One common criticism of path-finding in the Lightning network is that it is unsolvable because it is equivalent to the NP-complete _Traveling Salesperson Problem_, a fundamental problem in computational complexity theory. In fact, path finding in Lightning is not equivalent to TSP and falls into a different class of problems. We successfully solve these types of problems (path finding in graphs with incomplete information) every time we ask Google to give us driving directions with traffic avoidance. We also successfully solve this problem every time we route a payment on the Lightning network.
====

Path finding and routing can be implemented in a number of different ways and multiple path-finding and routing algorithms can co-exist on the Lightning network, just as multiple routing algorithms exist on the internet. Source-based routing is one of many possible solutions and is successful at the current scale of the Lightning network.

The path finding strategy currently implemented by Lightning nodes is to "probe" paths until one is found that has enough liquidity to forward the payment. This is an iterative process of trial and error, until success is achieved or no path is found. The algorithm currently does not necessarily result in the path with the lowest fees. While this is not optimal and certainly can be improved, even this simplistic strategy works quite well.

This "probing" is done by the Lightning node or wallet and is not directly seen by the user.
The user might only realize that probing is taking place if the payment does not complete instantly.

[NOTE]
====
On the Internet we use the internet protocol and an IP forwarding algorithm to forward internet packages from the sender to the destination. While these protocols have the nice property of allowing  internet hosts to collaboratively find a path for information flow through the internet, we cannot reuse and adopt this protocol for forwarding payments on the Lightning Network. Unlike the internet, Lightning payments have to be _atomic_ and channel balances have to remain _private_. Furthermore, the channel capacity in Lightning changes frequently, unlike the Internet where connection capacity is relatively static. These constraints require novel strategies.
====

Of course, path finding is trivial if we want to pay our direct channel partner and we have enough balance on our side of the channel to do so. In all other cases, our node uses information from the gossip protocol to do path finding. This includes currently known public payment channels, known nodes, known topology (how known nodes are connected), known channel capacities, and known fee policies set by the node owners.

==== Onion routing

The Lightning Network uses an _onion routing protocol_ similar to the famous TOR (The Onion Router) network.
The onion routing protocol used in Lightning is called the _SPHINX mixformat_ and will be explained in detail in a later chapter.

[NOTE]
====
Lightning's onion routing SPHINX mixformat is only similar to the TOR network routing in concept, but both the protocol and the implementation are entirely different from those use in the TOR network.
====

A payment package used for routing is called an "onion". footnote:[The term "onion" was originally used by the TOR project. Moreover, the Tor network is also called the Onion network and the project uses an onion as its logo. The top level domain name used by TOR services on the internet is ".onion".]

Let's use the onion analogy to follow a routed payment. On its route from payment sender (payer) to payment destination (payee) the onion is passed from node to node along the path. The sender constructs the entire onion, from the center out. First, the sender creates the payment information for the (final) recipient of the payment and encrypts it with a layer of encryption that only the recipient can decrypt. Then, the sender wraps that layer with instructions for the node in the path _immediately preceding the final recipient_ and encrypts with a layer that only that node can decrypt.

The layers are built up with instructions working backwards until the entire path is encoded in layers. The sender then gives the complete onion to the first node in the path that can only read the outermost layer. Each node peels a layer, and finds instructions inside revealing the next node in the path and passes the onion on. As each node peels one layer, it can't read the rest of the onion. All it knows is where the onion came from and where it is going next, without any indication as to who is the original sender or the ultimate recipient.

This continues until the onion reaches the payment destination (payee). Then, the destination node opens the onion and finds there are no further layers to decrypt and can read the payment information inside.

[NOTE]
====
Unlike a real onion, when peeling each layer, the nodes add some encrypted padding, to keep the size of the onion the same for the next node. As we will see, this makes it impossible for any of the intermediate nodes to know anything about the size (length) of the path, how many nodes are involved in routing, how many nodes preceded them or how many follow. This might increase privacy by preventing trivial traffic analysis attacks.
====

The onion routing protocol used in Lightning has the following properties:

. An intermediary node can only see on which channel it received an onion and on which channel to forward the onion. This means that no routing node can know who initiated the payment and to whom the payment is destined. This is the most important property and results in a high degree of privacy.

. The onions are small enough to fit into a single TCP/IP packet and even a link layer (e.g. Ethernet) frame. This makes traffic analysis of the payments significantly more difficult, increasing privacy further.

. The onions are constructed such that they will always have the same length independent of the position of the processing node along the path. As each layer is "peeled" the onion is padded with encrypted "junk" data to keep the size of the onion the same. This prevents intermediary nodes from knowing their position in the path.

. Onions have an HMAC (Hashed Message Authentication code) at each layer so that manipulations of onions are prevented and practically impossible

. Onions can have up to 20 hops or onion layers if you prefer. This allows for sufficiently long paths.

. The encryption of the onion for every hop uses different ephemeral encryption keys with every single onion. Should a key (in particular the private key of a node) leak at some point in time an attacker cannot decrypt them. In simpler terms, keys are never reused in order to achieve more security.

. Errors can be sent back from the erring node to the original sender, using the same onion routed protocol. Error onions are indistinguishable from routing onions, to external observers and intermediary nodes. Error routing enables the trial-and-error "probing" method used to find a path that has sufficient capacity to successfuly route a payment.

Onion routing will be examined in detail in <<onion_routing>>.

==== Payment Forwarding Algorithm

Once the sender of a payment finds a possible path across the network and constructs an onion, the payment is forwarded by each node in the path. Each node processes one layer of the onion and forwards it to the next node in the path.

Each intermediary node receives a Lightning Message called `update_add_htlc` with a payment hash and an onion. The intermediary node executes a series of steps, called the _payment forwarding algorithm_:

. The node decrypts the outer layer of the onion and checks the message's integrity.

. It confirms that it can fulfill the routing hints, based on the channel fees and available capacity on the outgoing channel.

. It works with its channel partner on the incoming channel to update the channel state.

. It adds some padding to the end of the onion to keep it at a constant length since it removed some data from the beginning.

. It follows the routing hints to forward the modified onion package on its outgoing payment channel by also sending an `update_add_htlc` message which includes the same payment hash and the onion.

. It works with its channel partner on the outgoing channel, to update the channel state.

Of course, these steps are interrupted and aborted if an error is detected and an error message is sent back to the originator of the `update_add_htlc` message. The error message is also formatted as an onion and sent backwards on the incoming channel.

As the error propagates backwards on each channel along the path, the channel partners remove the pending payment, rolling back the payment in the opposite way from which it started.

While the likelihood for a payment failure is high if it does not settle quickly, a node should never initiate another payment attempt along a different path before the onion returns with an error. The sender would pay twice if both payment attempts eventually succeeded.

=== Peer-to-Peer Communication Encryption

The Lightning Network protocol is mainly a peer-to-peer protocol between its participants. As we saw in previous sections, there are two overlapping functions in the network, forming two logical networks that together are _The Lightning Network_:

1. A broad peer-to-peer network that uses a gossip protocol to propagate topology information, where peers randomly connect to each other. Peers don't necessarily have payment channels between them, so they are not always channel partners.

2. A network of payment channels between channel partners. Channel partners also gossip about topology, meaning they are peer nodes in the gossip protocol.

All communication between peers is sent via messages called _Lightning Messages_. These messages are all encrypted, using a cryptographic communications framework called the _Noise Protocol Framework_. The Noise Protocol Framework allows the construction of cryptographic communication protocols that offer authentication, encryption, forward secrecy and identity privacy. The Noise Protocol Framework is also used in a number of popular end-to-end encrypted communications systems such as WhatsApp, Wireguard, and I2P. More information can be found here:

https://noiseprotocol.org/

The use of the Noise Protocol Framework in the Lightning Network ensures that every message on the network is both authenticated and encrypted, increasing the privacy of the network and its resistance to traffic analysis, deep packet inspection and eavesdropping. However, as a side-effect, this makes protocol development and testing a bit tricky as one can't simply observe the network with a packet capture or network analysis tool such as wireshark. Instead, developers have to use specialized plugins that decrypt the protocol from the perspective of one node, such as the _lightning dissector_, a wireshark plugin:

https://github.com/nayutaco/lightning-dissector

=== Thoughts about Trust
As long as a person follows the protocol and has their node secured, there is no major risk of losing funds when participating in the Lightning Network.
However, there is the cost of paying on-chain fees when opening a channel.
Any cost should come with a corresponding benefit.
In our case the reward for Alice for bearing the cost of opening a channel is that Alice can send and receive payments of bitcoin on the Lightning Network at any time and that she can earn fees in bitcoin by forwarding payments for other people.
Alice knows that in theory Bob can close the channel immediately after opening resulting in on-chain closing fees for Alice.
Alice will need to have a small amount of trust in Bob.
Alice has been to Bob's Cafe and clearly Bob is interested in selling her coffee, so Alice can trust Bob in this sense.
There are mutual benefits to both Alice and Bob.
Alice decides that the reward is enough for her to take on the cost of the on-chain fee for creating a channel to Bob.
In contrast, Alice will not open a channel to someone unknown in a foreign country who just sent her an uninvitedly email asking her to open a channel to him.

=== Comparison with Bitcoin

While the Lightning Network is built on top of Bitcoin and inherits many of its features and properties, there are important differences that users of both networks need to be aware of.

Some of these differences are differences of terminology. There are also architectural differences and differences in the user experience. In the next few sections we will examine the differences and similarities, explain the terminology and adjust our expectations.

==== Addresses vs Invoices, Transactions vs Payments

In typical payment using Bitcoin, a user receives a Bitcoin address (e.g. scanning a QR code on a webpage, or receiving it in an instant message or email from a friend). They then use their Bitcoin wallet to create a transaction to send funds to this address.

On the Lightning Network, the recipient of a payment creates an invoice. A Lightning invoice can be seen as analogous to a Bitcoin address. The intended recipient gives the Lightning invoice to the sender, as a QR code or character string, just like a Bitcoin address.

The sender uses their Lightning wallet to pay the invoice, copying the invoice text or scanning the invoice QR code. A Lightning payment is analogous to a Bitcoin "transaction".

There are some differences in the user experience however. A Bitcoin address is _reusable_. Bitcoin addresses never expire and if the owner of the address still holds the keys, the funds held within are always accessible. A sender can send any amount of bitcoin to a previously used address, and a recipient can post a single static address to receive many payments. While this goes against the best practices for privacy reasons, it is technically possible and in fact quite common.

In Lightning however, each invoice can only be used once for a specific payment amount. You cannot pay more or less, you cannot use an invoice again and the invoice has an expiry time built in. In Lightning, a recipient has to generate a new invoice for each payment, specifying the payment amount in advance. There is an exception to this, a mechanism called _keysend_, which we will examine in <<keysend>>.

==== Selecting Outputs vs Finding a Path

In order to make a payment on the Bitcoin network, a sender needs to consume one or more Unspent Transaction Outputs (UTXOs).
If a user has multiple UTXOs, they (or rather their wallet) will need to select which UTXO(s) to send.
For instance, a user making a payment of 1 BTC can use a single output with value 1 BTC, two outputs with value 0.25 BTC and 0.75 BTC, or four outputs with value 0.25 BTC each.

On Lightning, payments do not require inputs to be consumed, Instead each payment results in an update of the channel balance, redistributing it between the two channel partners. The sender experiences this as "moving" channel balance from their end of a channel to the other end, to their channel partner. Lightning payments use a series of channels to route from sender to recipient. Each of these channels must have sufficient capacity to route the payment.

As many possible channels and paths can be used to make a payment, the Lightning user's choice of channels and paths is somewhat analogous to the Bitcoin user's choice of UTXO.

With technologies such as Atomic Multi-Path (AMP) and Multi-Path Payments (MPP), which we will review in subsequent chapters, several Lightning paths can be aggregated into a single atomic payment, just like several Bitcoin UTXO can be aggregated into a single atomic Bitcoin transaction.

==== Change Outputs on Bitcoin vs No Change on Lightning

In order to make a payment on the Bitcoin network, the sender needs to consume one or more Unspent Transaction Outputs (UTXOs). UTXO can only be spent in full, they cannot be divided and partially spent. So if a user wishes to spend 0.8 BTC, but only has a 1 BTC UTXO, then they need to spend the entire 1 BTC UTXO and send 0.8 BTC to the recipient, and 0.2 BTC back to themselves as change. The 0.2 BTC change payment creates a new UTXO called a 'change output'.

On Lightning, the funding transaction spends some Bitcoin UTXO, creating a multi-signature UTXO to open the channel. Once the bitcoin is locked within that channel, portions of it can be sent back and forth within the channel, without the need to create any change.
This is because the channel partners simply update the channel balance and only create a new UTXO when the channel is eventually closed, with the channel closing transaction.

==== Mining Fees vs Routing Fees

On the Bitcoin network, users pay fees to miners to have their transactions included in a block.
These fees are paid to the miner who mines that particular block.
The amount of the fee is based on the _size_ of the transaction in _bytes_ that the transaction is using in a block, as well as how quickly the user wants that transaction mined.
As miners will typically mine the most profitable transactions first, a user who wants their transaction mined immediately will pay a _higher_ fee-per-byte, while a user who is not in a hurry will pay a _lower_ fee-per-byte.

On the Lightning Network, users pay fees to other (intermediary node) users to route payments through their channels.
In order to route a payment, an intermediary node will have to move funds in two or more channels they own, as well as transmit the data for the sender's payment. Typically, the routing user will charge the sender based on the _value_ of the payment, having established a minimum _base fee_ (a flat fee for each payment) and a _fee rate_ (a pro-rated fee proportional to the value of the payment). Higher value payments will thus cost more to route, and a market for liquidity is formed, where different users charge different fees for routing through their channels.

==== Varying Fees Depending Traffic vs Announced Fees

On the Bitcoin network, miners are profit-seeking and will typically include as many transactions in a block as possible, while staying within the block capacity called the _block weight_.

If there are more transactions in the queue (called the mempool) than can fit in a block, they will begin by mining the transactions that pay the highest fees per unit (bytes) of _transaction weight_.
Thus, when there are many transactions in the queue, users have to pay a higher fee to be included in the next block, or they have to wait until there are fewer transactions in the queue.
This naturally leads to the emergence of a fee market where users pay based on how urgently they need their transaction included in the next block.

The scarce resource on the Bitcoin network is the space in the blocks. Bitcoin users compete for block space. And the Bitcoin fee market is based on available block space. The scarce resource in the Lightning network is the channel liquidity (capacity of funds available for routing in channels) and channel connectivity (how many and well connected nodes your channels can reach). Lightning users compete for capacity and connectivity and therefore the Lightning fee market is driven by capacity and connectivity.

On the Lightning Network, users are paying fees to the users routing their payments. Routing a payment, in economic terms, is nothing more than providing and assigning capacity to the sender. Naturally, routers who charge lower fees for the same capacity will be more attractive to route through. Thus a fee market exists where routers are in competition with each other over the fees they charge to route payments through their channels.

==== Public Bitcoin Transactions vs Private Lightning Payments

On the Bitcoin network, every transaction is publicly visible on the Bitcoin blockchain. While the addresses involved are pseudonymous and are not typically tied to identity, they are still seen and validated by every other user on the network.
In addition, blockchain surveillance companies collect and analyze this data en-masse and sell it to interested parties such as private firms, governments and intelligence agencies.

Lightning Network payments, on the other hand, are almost completely private. Typically only the sender and the recipient are fully aware of the source, destination, and amount transacted in a particular payment. Furthermore, the receiver may not even know the source of the payment. As payments are onion-routed, the users who route the payment are only aware of the amount of the payment, but can neither determine the source nor the destination.

In summary, Bitcoin transactions are broadcast publicly and stored forever. Lightning payments are executed between a few selected peers and information about them is privately stored and only until the channel is closed. Creating mass surveillance and analysis tools equivalent to those used on Bitcoin will be impossible on Lightning.

==== Waiting for Confirmations vs Instant Settlement

On the Bitcoin network, transactions are only settled once they have been included in a block, in which case they are said to be "confirmed" in that block. As more blocks are mined, the transaction acquires more "confirmations" and is considered more secure.

On the Lightning Network, confirmations only matter for opening and closing channels on-chain. Once a funding transaction has reached a suitable number of confirmations (e.g. 3), the channel partners consider the channel open. As the bitcoin in the channel is secured by a smart contract that manages that channel, payments settle _instantly_ once received by the final recipient.
In practical terms, instant settlement means that payments take only a few seconds to execute and settle. As with Bitcoin, Lightning payments are not reversible.

Finally, when the channel is closed, a transaction is made on the Bitcoin network and once that transaction is confirmed the channel is considered closed.

==== Sending Arbitrary Amounts vs Capacity Restrictions

On the Bitcoin network, a user can send any amount of bitcoin that they own to another user, without capacity restrictions. A single transaction can theoretically send up to 21 million bitcoin as a payment.

On the Lightning Network, a user can only send as much bitcoin as currently exists on their side of a particular channel to a channel partner. For instance, if a user owns one channel with 0.4 BTC on their side, and another channel with 0.2 BTC on their side, then the maximum they can send with one payment is 0.4 BTC. This is true regardless of how much bitcoin the user currently has in their Bitcoin wallet.

Atomic Multi-Path Payments (AMPs) is a feature which, in the above example, allows the user to combine both their 0.4 BTC and 0.2 BTC channels to send a maximum of 0.6 BTC with one payment. AMPs are currently being tested across the Lightning Network, and are expected to be widely available and used by the time this book is completed. For more detail on AMPs, see <<atomic_multipath_payments>>.

If the payment is routed, every routing node along the routing path must have channels with capacity at least the same as the payment amount being routed. This must hold true for every single channel that the payment is routed through. The capacity of the lowest-capacity channel in a path sets the upper limit for the capacity of the entire path.

Hence, capacity and connectivity are critical and scarce resources in the Lightning network.

==== Incentives for Large Value Payment vs. Small Value Payments

The fee structure in Bitcoin is independent of the transaction value.
A $1 million transaction has the same fee as a $1 transaction on Bitcoin, assuming similar transaction size in bytes.
In Lightning the fee is a fixed base fee plus a percentage of the transaction value.
Therefore, in Lightning the payment fee increases with payment value.
These opposing fee structures create different incentives and lead to different usage in regards to transaction value.
A transaction of greater value will be cheaper on Bitcoin and hence users will prefer Bitcoin for large value transactions. Similarly, on the other end of the scale, users will prefer Lightning for small value transactions.

==== Using the Blockchain as a Ledger vs as a Court System

On the Bitcoin Network, every transaction is eventually recorded in a block on the blockchain.
The blockchain thus forms a complete history of every transaction since Bitcoin's creation, and a way to fully audit every bitcoin in existence.
Once a transaction is included in the blockchain it is final.
Thus, no disputes can arise and it is unambiguous how much bitcoin is controlled by a particular address at a particular point in the blockchain.

On the Lightning Network, the balance in a channel at a particular time is known only to the two channel partners, and is only made visible to the rest of the network when the channel is closed.
When the channel is closed, the final balance of the channel is submitted to the Bitcoin blockchain, and each partner receives their share of the bitcoin in that channel.
For instance, if the opening balance was 1 BTC paid by Alice, and Alice made a payment of 0.3 BTC to Bob, then the final balance of the channel is 0.7 BTC for Alice and 0.3 BTC for Bob.
If Alice tries to cheat by submitting the opening state of the channel to the Bitcoin blockchain, with 1 BTC for Alice and 0 BTC for Bob, then Bob can retaliate by submitting the true final state of the channel, as well as create a penalty transaction that gives him all bitcoin in the channel.
For the Lightning network, the Bitcoin blockchain acts as a court system.
Like a robotic judge, Bitcoin records the initial and final balances of each channel, and approves penalties if one of the parties tries to cheat.

==== Offline vs Online, Asynchronous vs Synchronous

When a Bitcoin user sends funds to a destination address he does not need to know anything about the recipient. The recipient might be offline or online, and no interaction between sender and recipient is needed. The interaction is between sender and the Bitcoin blockchain. Receiving bitcoin on the Bitcoin blockchain is a _passive_ and _asynchronous_ activity that does not require any interaction by the recipient, or for the recipient to be online at any time. Bitcoin addresses can even be generated offline and are never "registered" with the Bitcoin network. Only spending bitcoin requires interaction.

In Lightning, the recipient must be "online" in order to complete the payment before it expires.
The recipient must run a node or have someone that runs a node on their behalf (a third-party custodian). To be precise, both nodes, the sender's and the recipient's must be online at the time of payment and must coordinate. Receiving a Lightning payment is an _active_ and _synchronous_ activity between sender and recipient, without the participation of most of the Lightning network or the Bitcoin network (except for the intermediary routing nodes, if any).

The synchronous and always-online nature of the Lightning network is probably the biggest difference in the user experience and often confounds users who are accustomed to Bitcoin.

==== Satoshis vs. milli-satoshis

On Bitcoin the smallest amount is a _satoshi_ which cannot be divided any further. Lightning is a bit more flexible, and Lightning nodes work with _milli-satoshis_ (thousandths of a satoshi). This allows tiny payments to be sent via Lightning. A single milli-satoshi payment can be sent across a payment channel, an amount so small it should properly be characterized as a _nanopayment_.

The milli-satoshi unit cannot, of course, be settled on the Bitcoin blockchain at that granularity. Upon channel closure, balances are rounded to the nearest satoshi. But over the lifetime of a channel, millions of nanopayments are possible at milli-satoshi levels. The Lightning network breaks throught the micropayment barrier.

=== Commonality of Bitcoin and Lightning

==== Monetary Unit

Both the Bitcoin network and the Lightning network use the same monetary units: bitcoin. Lightning payments use the very same bitcoin as Bitcoin transactions. As an implication, because the monetary unit is the same, the monetary limit is the same: less than 21 million bitcoin. Of Bitcoin's 21 million total bitcoin, some are already allocated to 2-of-2 multi-signature addresses as part of payment channel on the Lightning Network.

==== Irreversibility and finality of payments

Both Bitcoin transactions and Lightning payments are irreversible and immutable. There is no "undo" operation or "chargeback" for either system. As a sender of either one you have to act responsibly, but also, as a recipient you are guaranteed finality of your transactions.

==== Trust and counterparty risk

Just as Bitcoin, Lightning requires the user only to trust mathematics, encryption, and that the software does not have any critical bugs. Neither Bitcoin nor Lightning require the user to trust a person, a company, an institution, or a government.
Since Lightning sits on top of Bitcoin and relies on Bitcoin as its underlying base layer, it is clear that the security model of Lightning reduces to the security of Bitcoin. This means that Lightning offers broadly the same security as Bitcoin under most circumstances, with only a slight reduction in security under some narrow circumstances.

==== Permissionless operation

Both Bitcoin and Lightning can be used by anybody with access to the Internet and to the appropriate software, e.g. node and wallet.
Neither network requires users to get permission, vetting, or authorization from third-parties, companies, institutions or a government. Governments can outlaw Bitcoin or Lightning within their jurisdiction, but cannot prevent their global use.

==== Open source and open system

Both, Bitcoin and Lightning are open-source software systems built by a decentralized global community of volunteers, available under open licenses. Both are based on open and interoperable protocols, which operate as open systems and open networks. Global, open and free.

=== Conclusion

In this chapter we looked at how the Lightning network actually works and all of the constituent components. We examined each step in constructing, operating and closing a channel. We looked at how payments are routed. Finally we compared Lightinng and Bitcoin and analyzed their differences and commonalities.

In the next several chapters we will revisit all these topics, but in much more detail.
